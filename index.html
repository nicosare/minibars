<!DOCTYPE html>

<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Минибары</title>
    <!-- Базовые favicon -->
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

<!-- PNG favicon (для современных браузеров) -->
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="48x48" href="favicon.ico"> <!-- .ico содержит 48x48 -->

<!-- Apple Touch Icon (для iOS) -->
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

<!-- Android Chrome Icons -->
<link rel="icon" type="image/png" sizes="192x192" href="android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="android-chrome-512x512.png">

<!-- Web App Manifest (для PWA) -->
<link rel="manifest" href="site.webmanifest">

<!-- Для Microsoft приложений -->
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&amp;display=swap" rel="stylesheet"/>
<!-- PDF.js для парсера депатчеров -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<!-- Firebase App (обязательный скрипт для Firebase) -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js">/* ====== GIH SUMMARY ====== */
function updateGIHSummary() {
    const container = document.getElementById("gih-summary");
    const listEl = document.getElementById("gih-summary-list");
    if (!container || !listEl) return;

    // Считаем все продукты
    const counts = {};
    (appData.gihRecords || []).forEach(rec => {
        (rec.products || []).forEach(p => {
            if (!p || !p.name) return;
            counts[p.name] = (counts[p.name] || 0) + 1;
        });
    });

    // Если нет данных, скрываем блок
    const entries = Object.entries(counts);
    if (entries.length === 0) {
        container.style.display = "none";
        listEl.innerHTML = "";
        return;
    }

    // Сортируем по убыванию
    entries.sort((a, b) => b[1] - a[1]);

    // Формируем HTML-список
    const htmlParts = entries.map(([key, count]) => {
        const name = appData.products[key] || key;
        return `<div><strong>${name}</strong> x${count}</div>`;
    });

    listEl.innerHTML = htmlParts.join("");
    container.style.display = "block";
}



        function applySummaryState() {
            if (isCollapsed) {
                summaryList.style.display = "none";
                toggleBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
            } else {
                summaryList.style.display = "block";
                toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
            }
        }



        function applySummaryState() {
            if (isCollapsed) {
                summaryList.classList.add("collapsed");
                icon.classList.remove("fa-chevron-up");
                icon.classList.add("fa-chevron-down");
            } else {
                summaryList.classList.remove("collapsed");
                icon.classList.remove("fa-chevron-down");
                icon.classList.add("fa-chevron-up");
            }
        }


  mo.observe(list, { childList: true, subtree: true, characterData: true });

  // Recalculate on resize when expanded
  window.addEventListener("resize", () => {
    if (!isCollapsed) {
      list.style.maxHeight = "auto";
      const h = list.scrollHeight;
      list.style.maxHeight = h + "px";
    }
  });

  // Toggle handler
  btn.addEventListener("click", () => {
    isCollapsed = !isCollapsed;
    localStorage.setItem("gihSummaryCollapsed", String(isCollapsed));
    apply();
  });

  // Kick off
  apply();


  mo.observe(list, { childList: true, subtree: true, characterData: true });

  window.addEventListener("resize", () => {
    if (!isCollapsed) {
      list.style.maxHeight = "auto";
      list.style.maxHeight = list.scrollHeight + "px";
    }
  });

  // Клик по блоку
  summary.addEventListener("click", () => {
    isCollapsed = !isCollapsed;
    localStorage.setItem("gihSummaryCollapsed", String(isCollapsed));
    applyState();
  });

  // Стартовое состояние
  applyState();


mo.observe(list, { childList: true, subtree: true, characterData: true });

  // Пересчёт при ресайзе
  window.addEventListener("resize", () => {
    if (!isCollapsed) {
      list.style.maxHeight = "auto";
      list.style.maxHeight = list.scrollHeight + "px";
    }
  });

  // Клик по блоку
  summary.addEventListener("click", () => {
    isCollapsed = !isCollapsed;
    localStorage.setItem("gihSummaryCollapsed", String(isCollapsed));
    applyState();
  });

  // Применяем стартовое состояние
  applyState();


/* ====== GIH ROOMS SUMMARY (numbers) ====== */
function updateGIHRoomsSummary() {
  const cont = document.getElementById('gih-rooms-summary');
  const list = document.getElementById('gih-rooms-summary-list');
  const savedEl = document.getElementById('rooms-saved-count');
  const totalEl = document.getElementById('rooms-total-count');
  if (!cont || !list) return;

  const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
  const total = records.length;
  const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

  // counters
  if (savedEl) savedEl.textContent = String(saved);
  if (totalEl) totalEl.textContent = String(total);

  // empty state hides the block (consistently with products summary)
  if (total === 0) {
    cont.style.display = 'none';
    list.innerHTML = '';
    return;
  } else {
    cont.style.display = 'block';
  }

  // chips
  let html = '';
  records.forEach((rec, i) => {
    const isSaved = !!rec.savedAt;
    const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
    const savedClass = isSaved ? ' saved' : '';
    html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
  });
  list.innerHTML = html;

  // scroll + flash
  list.querySelectorAll('.room-chip').forEach(chip => {
    chip.addEventListener('click', () => {
      const id = chip.getAttribute('data-id');
      const card = document.querySelector('.gih-card[data-id="' + id + '"]');
      if (!card) return;
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
      card.classList.remove('highlighted');
      void card.offsetWidth; // reflow to restart animation
      card.classList.add('highlighted');
      setTimeout(() => card.classList.remove('highlighted'), 800);
    });
  });
}

// toggle (collapsed/expanded) like products list
(function initGIHRoomsToggle(){
  const box = document.getElementById('gih-rooms-summary');
  const arrow = document.getElementById('gih-rooms-summary-arrow');
  const list = document.getElementById('gih-rooms-summary-list');
  if (!box || !arrow || !list) return;

  let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
  isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
  function apply(){
    box.classList.toggle('collapsed', isCollapsed === 'true');
    box.classList.toggle('expanded',  isCollapsed === 'false');
    // compute max-height on expand to animate smoothly
    if (isCollapsed === 'false') {
      list.style.maxHeight = list.scrollHeight + 'px';
      list.style.opacity = '1';
    } else {
      list.style.maxHeight = '0';
      list.style.opacity = '0';
    }
  }
  box.addEventListener('click', () => {
    isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
    localStorage.setItem('gihRoomsCollapsed', isCollapsed);
    apply();
  });
  apply();
})();</script>
<!-- Firebase Realtime Database -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js">/* ====== GIH SUMMARY ====== */
function updateGIHSummary() {
    const container = document.getElementById("gih-summary");
    const listEl = document.getElementById("gih-summary-list");
    if (!container || !listEl) return;

    // Считаем все продукты
    const counts = {};
    (appData.gihRecords || []).forEach(rec => {
        (rec.products || []).forEach(p => {
            if (!p || !p.name) return;
            counts[p.name] = (counts[p.name] || 0) + 1;
        });
    });

    // Если нет данных, скрываем блок
    const entries = Object.entries(counts);
    if (entries.length === 0) {
        container.style.display = "none";
        listEl.innerHTML = "";
        return;
    }

    // Сортируем по убыванию
    entries.sort((a, b) => b[1] - a[1]);

    // Формируем HTML-список
    const htmlParts = entries.map(([key, count]) => {
        const name = appData.products[key] || key;
        return `<div><strong>${name}</strong> x${count}</div>`;
    });

    listEl.innerHTML = htmlParts.join("");
    container.style.display = "block";
}


/* ====== GIH ROOMS SUMMARY (numbers) ====== */
function updateGIHRoomsSummary() {
  const cont = document.getElementById('gih-rooms-summary');
  const list = document.getElementById('gih-rooms-summary-list');
  const savedEl = document.getElementById('rooms-saved-count');
  const totalEl = document.getElementById('rooms-total-count');
  if (!cont || !list) return;

  const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
  const total = records.length;
  const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

  // counters
  if (savedEl) savedEl.textContent = String(saved);
  if (totalEl) totalEl.textContent = String(total);

  // empty state hides the block (consistently with products summary)
  if (total === 0) {
    cont.style.display = 'none';
    list.innerHTML = '';
    return;
  } else {
    cont.style.display = 'block';
  }

  // chips
  let html = '';
  records.forEach((rec, i) => {
    const isSaved = !!rec.savedAt;
    const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
    const savedClass = isSaved ? ' saved' : '';
    html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
  });
  list.innerHTML = html;

  // scroll + flash
  list.querySelectorAll('.room-chip').forEach(chip => {
    chip.addEventListener('click', () => {
      const id = chip.getAttribute('data-id');
      const card = document.querySelector('.gih-card[data-id="' + id + '"]');
      if (!card) return;
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
      card.classList.remove('highlighted');
      void card.offsetWidth; // reflow to restart animation
      card.classList.add('highlighted');
      setTimeout(() => card.classList.remove('highlighted'), 800);
    });
  });
}

// toggle (collapsed/expanded) like products list
(function initGIHRoomsToggle(){
  const box = document.getElementById('gih-rooms-summary');
  const arrow = document.getElementById('gih-rooms-summary-arrow');
  const list = document.getElementById('gih-rooms-summary-list');
  if (!box || !arrow || !list) return;

  let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
  isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
  function apply(){
    box.classList.toggle('collapsed', isCollapsed === 'true');
    box.classList.toggle('expanded',  isCollapsed === 'false');
    // compute max-height on expand to animate smoothly
    if (isCollapsed === 'false') {
      list.style.maxHeight = list.scrollHeight + 'px';
      list.style.opacity = '1';
    } else {
      list.style.maxHeight = '0';
      list.style.opacity = '0';
    }
  }
  box.addEventListener('click', () => {
    isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
    localStorage.setItem('gihRoomsCollapsed', isCollapsed);
    apply();
  });
  apply();
})();</script>
<style>
    @media (min-width: 921px) {
        nav, .nav {
            position: fixed !important;
            top: 18px;
            left: 18px;
            width: 220px;
            height: auto;
            max-height: calc(100vh - 36px);
            overflow-y: auto;
            z-index: 999;
            margin: 0;
        }

        .content {
            margin-left: 250px !important; /* 220px + 30px отступ */
            width: calc(100% - 250px);
        }

        body {
            padding: 18px;
        }
    }

    /* === МОБИЛЬНАЯ ШАПКА С ОТСТУПАМИ === */
    @media (max-width: 920px) {
        .mb-header {
            position: fixed;
            top: 12px;
            left: 12px;
            right: 12px;
            width: auto;
            margin: 0;
            z-index: 1000;
            border-radius: 0 !important;
        }

        body {
            margin-top: 18px !important; /* Отступ для шапки */
            padding-left: 12px;
            padding-right: 12px;
        }

        .content {
            margin-left: 0 !important;
            width: 100%;
        }
    }
    /* ==== Calculator minimalist chips ==== */
    .calc-chip {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 6px;     
        border-radius: 999px;
        border: 1px solid rgba(15,23,36,0.06);
        background: transparent;
        box-shadow: none;
        user-select: none;
    }
    .calc-chip:hover {
        background: rgba(39,103,73,0.06);
    }
    .calc-op {
        cursor: pointer;
        font-weight: 700;
        color: var(--primary-strong);
        padding: 0 6px;
        line-height: 1;
    }
    .calc-op.disabled {
        opacity: 0.35;
        cursor: default;
        pointer-events: none;
    }
    .calc-label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
    }
    .calc-price {
        color: var(--muted);
        font-weight: 400;
        font-size: 12px;
    }
    .calc-count {
        min-width: 20px;
        text-align: center;
        color: var(--muted);
        font-weight: 700;
        font-size: 12px;
    }

    /* === НИЖНЯЯ НАВИГАЦИЯ НА МОБИЛЬНЫХ === */
    @media (max-width: 920px) {
        .bottom-nav {
            position: fixed;
            left: 12px;
            right: 12px;
            bottom: 12px;
            width: auto;
            margin: 0;
            border-radius: 12px;
        }
    }

    /* === ОСНОВНЫЕ СТИЛИ ОСТАЮТСЯ БЕЗ ИЗМЕНЕНИЙ === */
    :root {
        --bg: #f6f7fb;
        --card: #fff;
        --muted: #8b95a3;
        --text: #0f1724;
        --primary: #276749;
        --primary-strong: #1b5e20;
        --accent: #ff8a00;
        --radius: 14px;
        --shadow-sm: 0 6px 18px rgba(12,18,24,0.06);
        --transition: 200ms ease;
        --bottom-nav-height: 70px;
        --safe-bottom: env(safe-area-inset-bottom, 12px);
    }

    * {
        box-sizing: border-box;
        font-family: 'Inter',system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
        margin: 0;
        padding: 0;
    }

    html, body {
        height: 100%;
    }

    body {
        background: var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        flex-direction: column;
    }

    .app {
        display: flex;
        gap: 20px;
        width: 100%;
    }

    /* Упрощенные переходы без конфликтов */
    .btn, .product-btn, .room-item, .gih-product, .nav-item, 
    .b-item, .mb-burger-item, .accordion-header, .room-chip,
    .mode-btn, .card, .gih-card, .input, .calc-chip {
        transition: 
            background-color var(--transition),
            border-color var(--transition),
            box-shadow var(--transition),
            color var(--transition),
            opacity var(--transition) !important;
    }

    /* Убираем все трансформации */
    .btn, .product-btn, .room-item, .gih-product, .card {
        transform: none !important;
    }

    /* LEFT NAV (desktop) */
    .nav {
        width: 220px;
        background: var(--card);
        border-radius: 12px;
        padding: 14px;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        gap: 8px;
        height: fit-content;
    }

    .logo {
        font-weight: 700;
        color: var(--primary);
        font-size: 16px;
        padding: 8px 6px;
    }

    .nav-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        border-radius: 10px;
        color: var(--muted);
        cursor: pointer;
    }

    .nav-item.active {
        background: rgba(39,103,73,0.09);
        color: var(--primary-strong);
        box-shadow: 0 6px 14px rgba(39,103,73,0.06);
    }

    .nav-item:hover:not(.active) {
        background: rgba(39,103,73,0.05);
    }

    .content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 18px;
    }

    .card {
        background: var(--card);
        border-radius: var(--radius);
        padding: 14px;
        box-shadow: var(--shadow-sm);
    }

    .muted {
        color: var(--muted);
        font-size: 13px;
    }

    .row {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .hidden {
        display: none !important;
    }

    /* Секции вкладок - управляются через JavaScript */
    .card[id$="-section"] {
        display: none !important;
    }
    
    .card[id$="-section"].show {
        display: block !important;
    }
    
    .card[id$="-section"].hidden {
        display: none !important;
    }
    
    /* По умолчанию показываем только первую вкладку */
    

    .input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(15,23,36,0.06);
        background: transparent;
        color: var(--text);
    }

    .input:focus {
        border-color: var(--primary);
        outline: none;
        box-shadow: 0 0 0 2px rgba(39,103,73,0.1);
    }

    .rooms-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill,minmax(120px,1fr));
        gap: 12px;
        margin-top: 12px;
    }

    #rooms-grid {
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin-top: 12px;
    }

    .deadlines-floor-section {
        padding: 12px;
        border-radius: 12px;
        background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.6));
        box-shadow: 0 3px 10px rgba(12,18,24,0.04);
        border: 1px solid rgba(15,23,36,0.05);
    }

    .deadlines-floor-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 10px;
        cursor: pointer;                /* курсор-рука при наведении */
    user-select: none;              /* запрет выделения текста */
    transition: background 0.2s, color 0.2s;
        color: var(--primary-strong);
    }

    .deadlines-room-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .deadlines-room-item {
        min-width: 72px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(15,23,36,0.08);
        background: rgba(15,23,36,0.02);
        text-align: center;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, background 0.15s ease;
    user-select: none;
    }

    .deadlines-room-item:hover {
        box-shadow: 0 6px 12px rgba(12,18,24,0.12);
    }

    .deadlines-room-number {
        font-weight: 700;
        font-size: 16px;
    }

    .deadlines-room-item.status-empty {
        border: 1px solid rgba(15,23,36,0.08);
        background: rgba(15,23,36,0.02);
    }

    .deadlines-room-item.status-alert {
        background: rgba(220,53,69,0.12);
        border-color: rgba(220,53,69,0.4);
        color: #c12a35;
    }

    .deadlines-room-item.status-ok {
        background: rgba(39,103,73,0.14);
        border-color: rgba(39,103,73,0.45);
        color: #215c40;
    }

    .deadlines-room-item.selected {
        border: 2px solid var(--primary);
        box-shadow: 0 0 0 2px rgba(39,103,73,0.2);
    }

    #modal-ok-order.deadlines-applied {
        background: var(--primary);
        color: #fff;
        border-color: var(--primary);
    }

    .room-item {
        padding: 12px;
        border-radius: 12px;
        cursor: pointer;
        border: 1px solid rgba(15,23,36,0.04);
        background: linear-gradient(180deg,rgba(255,255,255,0.6),rgba(255,255,255,0.46));
        min-height: 82px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .room-item:hover {
        box-shadow: 0 6px 15px rgba(12,18,24,0.08);
        background: linear-gradient(180deg,rgba(255,255,255,0.8),rgba(255,255,255,0.6));
    }

    .room-number {
        font-weight: 700;
        font-size: 18px;
        color: var(--primary-strong);
    }

    .room-products {
        color: var(--muted);
        font-size: 13px;
        margin-top: 8px;
        text-align: center;
    }

    .room-item.completed {
        background: linear-gradient(180deg, rgba(39,103,73,0.08), rgba(39,103,73,0.02));
        border-color: rgba(39,103,73,0.12);
    }

    .room-item.has-products {
        background: linear-gradient(180deg, rgba(255,138,0,0.06), rgba(255,138,0,0.02));
        border-color: rgba(255,138,0,0.12);
    }

    /* Overlay modal */
    .overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(10,12,18,0.36);
        z-index: 1400;
        padding: 22px;
    }

    .modal {
        width: 100%;
        max-width: 920px;
        border-radius: 14px;
        padding: 18px;
        background: linear-gradient(180deg,rgba(255,255,255,0.98),rgba(250,250,250,0.98));
        box-shadow: 0 30px 80px rgba(6,10,15,0.3);
        transform: translateY(18px);
        opacity: 0;
        transition: transform 300ms ease,opacity 300ms ease;
        max-height: 90vh;
        overflow: auto;
    }

    .overlay.show {
        display: flex;
    }

    .modal.show {
        transform: translateY(0);
        opacity: 1;
    }

    .modal-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
    }

    .products-wrap {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        padding: 8px;
        max-height: 48vh;
        overflow: auto;
        border-radius: 10px;
        background: transparent;
    }

    .product-btn {
        position: relative;
    min-width: 110px;
    padding: 8px 12px;
    border-radius: 12px;
    border: 1px solid rgba(15,23,36,0.06);
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    /* Фиксированная ширина с учетом места для счетчика */
    padding-right: 30px;
    /* Добавляем перенос текста */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    }

    .product-btn:hover {
        box-shadow: 0 4px 12px rgba(12,18,24,0.08);
        background: rgba(39,103,73,0.02);
    }

    .product-btn.active {
        background: var(--primary);
        color: #fff;
        border-color: var(--primary-strong);
    }

    .product-count {
    position: absolute;
    right: 3px;
    top: 50%;
    transform: translateY(-50%);
    background: var(--accent);
    color: #fff;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 11px;
    line-height: 1;
    flex-shrink: 0;
}
    .product-count:empty {
    background: transparent;
    border: 1px solid rgba(15,23,36,0.2);
}

    .gih-form {
        display: none;
        gap: 10px;
        margin-top: 12px;
    }

    .gih-products-area {
        padding: 8px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        border-radius: 10px;
        border: 1px solid rgba(15,23,36,0.04);
        max-height: 400px;
        overflow: auto;
        background: transparent;
    }

    .gih-records {
        display: grid;
        grid-template-columns: repeat(auto-fill,minmax(320px,1fr));
        gap: 12px;
        margin-top: 12px;
    }

    .gih-card {
        padding: 14px;
        border-radius: 12px;
        background: var(--card);
        box-shadow: var(--shadow-sm);
        position: relative;
        overflow: hidden;
    }

    .gih-products {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
    }

    .gih-product {
        padding: 8px 10px;
        border-radius: 10px;
        background: var(--card);
        font-size: 13px;
        border: 1px solid rgba(15,23,36,0.04);
        cursor: pointer;
    }

    .gih-product:hover {
        background: rgba(39,103,73,0.05);
    }

    .gih-product.disabled {
        opacity: 0.6;
        pointer-events: none;
    }

    .status-0 {
        background: #fff;
        color: var(--text);
        border-color: rgba(15,23,36,0.06);
        text-decoration: none;
    }

    .status-1 {
        background: #bfeec0;
        color: #064e17;
        border-color: rgba(39,103,73,0.12);
    }

    .status-2 {
        background: #bfe0f6;
        color: #044a6a;
        border-color: rgba(11,111,176,0.12);
        text-decoration: line-through;
    }

    .status-3 {
        background: #e0e0e0;
        color: #333;
        border-color: rgba(120,120,120,0.12);
    }

    .status-4 {
        background: #f7bdbd;
        color: #6b0b0b;
        border-color: rgba(229,62,62,0.12);
    }

    .legend {
        margin-top: 8px;
        font-size: 13px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
    }

    .legend .item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border-radius: 8px;
    }

    .legend .color {
        width: 14px;
        height: 14px;
        border-radius: 4px;
        display: inline-block;
        border: 1px solid rgba(15,23,36,0.04);
    }

    .legend .t-added {
        background: #bfeec0;
    }

    .legend .t-here {
        background: #bfe0f6;
    }

    .legend .t-out {
        background: #e0e0e0;
    }

    .legend .t-miss {
        background: #f7bdbd;
    }

    .gih-footer {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
    }

    .gih-footer .mode-btn {
        border: 1px solid rgba(15,23,36,0.08);
        background: #fff;
        color: var(--primary-strong);
        padding: 6px 10px;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 600;
    }

    .gih-footer .mode-btn.active {
        background: var(--primary);
        color: #fff;
        border-color: var(--primary-strong);
        box-shadow: 0 4px 10px rgba(39,103,73,0.1);
    }

    .gih-footer .mode-btn:hover:not(.active) {
        border-color: var(--primary);
        background: rgba(39,103,73,0.05);
    }

    .gih-footer .mode-btn[disabled] {
        opacity: 0.55;
        pointer-events: none;
    }

    .muted-note {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
    }

    .btn {
        border: none;
        border-radius: 999px;
        padding: 8px 12px;
        cursor: pointer;
        font-weight: 600;
        color: #fff;
        background: var(--primary);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        min-height: 40px;
        position: relative;
        overflow: hidden;
    }

    .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }

    .btn:hover::before {
        left: 100%;
    }

    .btn:hover {
        background: var(--primary-strong);
        box-shadow: 0 4px 12px rgba(39,103,73,0.2);
    }

    .btn.ghost {
        background: transparent;
        color: var(--primary-strong);
        border: 1px solid rgba(15,23,36,0.04);
    }

    .btn.ghost:hover {
        background: rgba(39,103,73,0.05);
    }

    .btn.small {
        padding: 6px 10px;
        font-size: 13px;
    }

    .btn.secondary {
        background: var(--card);
        color: var(--primary-strong);
        border: 1px solid rgba(15,23,36,0.06);
    }

    .btn.secondary:hover {
        border-color: var(--primary);
    }

    .card-save {
        background: #2f9d3a;
        color: #fff;
        border: none;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 700;
    }

    .card-save:hover:not([disabled]) {
        background: #278c32;
        box-shadow: 0 4px 10px rgba(39,103,73,0.2);
    }

    .card-save[disabled] {
        opacity: 0.45;
        cursor: not-allowed;
    }

    .card-save-wrap {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
        flex-direction: column;
        min-width: 160px;
    }

    .saved-at {
        font-size: 13px;
        color: #1b7a2b;
        margin-top: 6px;
    }

    .card-footer-row {
        display: flex;
        justify-content: flex-end;
        align-items: flex-end;
        gap: 12px;
        margin-top: 12px;
    }

    /* Убираем анимации при нажатии для всех элементов */
    .btn:active, .product-btn:active, .room-item:active, 
    .gih-product:active, .nav-item:active, .b-item:active,
    .mb-burger-item:active, .mode-btn:active {
        transform: none !important;
        transition: none !important;
    }

    /* MOBILE: touch-friendly tweaks */
    .btn {
        min-height: 44px;
        padding: 12px 14px;
    }

    .product-btn {
        min-height: 44px;
        padding: 10px 12px;
    }

    .room-item {
        min-height: 90px;
        padding: 14px;
    }

    /* MOBILE: bottom navigation */
    .bottom-nav {
        display: none;
        height: var(--bottom-nav-height);
        background: var(--card);
        border-radius: 14px;
        box-shadow: 0 12px 30px rgba(6,10,15,0.12);
        align-items: center;
        justify-content: space-around;
        z-index: 1600;
        padding: 8px;
        transition: transform 300ms ease, opacity 300ms ease;
    }

    .bottom-nav.hide {
        transform: translateY(120%);
        opacity: 0;
        pointer-events: none;
    }

    .bottom-nav .b-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        color: var(--muted);
        font-size: 12px;
        cursor: pointer;
        padding: 6px 8px;
        border-radius: 8px;
    }

    .bottom-nav .b-item.active {
        color: var(--primary-strong);
        background: rgba(39,103,73,0.08);
    }

    .bottom-nav .b-item:hover {
        background: rgba(39,103,73,0.05);
    }
    /* Полное отключение всех эффектов для GIH продуктов */
.gih-product {
    -webkit-tap-highlight-color: transparent !important;
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    transition: none !important;
    pointer-events: auto !important;
}

/* Убираем ВСЕ эффекты при наведении */
.gih-product:hover {
    background-color: inherit !important;
    color: inherit !important;
    border-color: inherit !important;
    box-shadow: none !important;
    transform: none !important;
    cursor: pointer !important;
}

/* Убираем ВСЕ эффекты при клике/активном состоянии */
.gih-product:active,
.gih-product:focus,
.gih-product:focus-visible,
.gih-product:focus-within {
    background-color: inherit !important;
    color: inherit !important;
    border-color: inherit !important;
    box-shadow: none !important;
    transform: none !important;
    outline: none !important;
}

/* Убираем псевдоэлементы и их эффекты */
.gih-product::before,
.gih-product::after,
.gih-product:hover::before,
.gih-product:hover::after,
.gih-product:active::before,
.gih-product:active::after {
    content: none !important;
    opacity: 0 !important;
    display: none !important;
}


/* Принудительно применяем стили статуса всегда */
.gih-product.status-0 { background: #fff !important; color: var(--text) !important; border-color: rgba(15,23,36,0.06) !important; }
.gih-product.status-1 { background: #bfeec0 !important; color: #064e17 !important; border-color: rgba(39,103,73,0.12) !important; }
.gih-product.status-2 { background: #bfe0f6 !important; color: #044a6a !important; border-color: rgba(11,111,176,0.12) !important; }
.gih-product.status-3 { background: #e0e0e0 !important; color: #333 !important; border-color: rgba(120,120,120,0.12) !important; }
.gih-product.status-4 { background: #f7bdbd !important; color: #6b0b0b !important; border-color: rgba(229,62,62,0.12) !important; }

/* Убираем любые дополнительные классы, которые могут добавляться */
.gih-product.disabled {
    opacity: 0.6 !important;
    pointer-events: none !important;
}

/* Отключаем любые анимации для этих элементов */
.gih-product {
    animation: none !important;
}

    /* MOBILE: modal full screen */
    @media (max-width:920px) {
        .nav {
            display: none;
        }
        
        .rooms-grid {
            grid-template-columns: repeat(2,1fr);
        }

        .gih-records {
            grid-template-columns: 1fr;
        }

        .modal {
            width: 100%;
            max-width: 100%;
            height: calc(100vh - 90px);
            max-height: none;
            border-radius: 12px;
            padding: 14px;
        }

        .overlay {
            align-items: flex-start;
            padding-top: 70px;
        }

        .modal-head {
            margin-bottom: 8px;
        }

        .products-wrap {
            max-height: 36vh;
        }

        .gih-products {
            gap: 6px;
        }

        .product-btn {
        min-width: 90px;
        padding: 10px 12px;
        /* Увеличиваем правый отступ для счетчика */
        padding-right: 35px;
        /* Уменьшаем минимальную ширину для мобильных */
        min-width: 85px;
    }
    .product-count {
        /* Уменьшаем размер счетчика на мобильных */
        width: 18px;
        height: 18px;
        font-size: 10px;
        right: 10px;
    }

        .card {
            padding: 12px;
            border-radius: 12px;
        }

        .bottom-nav {
            display: flex;
        }
    }
    
    @media (max-width: 920px) {
    .gih-products-area .product-btn {
        min-width: 85px;
        padding: 10px 8px;
        padding-right: 32px;
        font-size: 12px;
    }
    
    .gih-row .product-btn {
        min-width: 80px;
    }
}

/* Убедимся, что текст не выходит за пределы */
.product-btn .btn-text {
    flex: 1;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

    /* MOBILE: very small screens */
    @media (max-width:480px) {
        .rooms-grid {
            grid-template-columns: 1fr;
        }

        .product-btn {
            min-width: 80px;
            padding-right: 32px;
            font-size: 12px;
        }
        .product-count {
            width: 16px;
            height: 16px;
            font-size: 9px;
            right: 8px;
        }

        .modal {
            padding-bottom: calc(var(--safe-bottom) + 18px);
            border-radius: 12px;
        }

        .card-save-wrap {
            min-width: 140px;
        }

        .input {
            padding: 12px;
            font-size: 16px;
        }

        .gih-form > div {
            flex-direction: column;
            gap: 10px;
        }

        .gih-form .input[style] {
            width: 100% !important;
        }

        .card-footer-row {
            flex-direction: column;
            align-items: stretch;
        }
    }

    /* small visual polish for bottom nav icons */
    .bottom-nav i {
        font-size: 18px;
    }

    .bottom-nav .b-label {
        font-size: 11px;
    }

    /* Firebase connection status */
    .connection-status {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 8px;
        font-size: 12px;
        background: var(--card);
        box-shadow: var(--shadow-sm);
        margin-top: 8px;
        transition: var(--transition);
    }

    .connection-status.connected {
        color: var(--primary-strong);
    }

    .connection-status.disconnected {
        color: #e53e3e;
    }

    .connection-status .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        transition: var(--transition);
    }

    .connection-status.connected .dot {
        background: var(--primary-strong);
        box-shadow: 0 0 0 2px rgba(39,103,73,0.2);
    }

    .connection-status.disconnected .dot {
        background: #e53e3e;
        box-shadow: 0 0 0 2px rgba(229,62,62,0.2);
    }

    /* Mobile-only connection indicator */
    .mobile-connection-indicator {
        display: none;
        position: absolute;
        top: 10px;
        left: 10px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        z-index: 10;
        transition: var(--transition);
    }

    .mobile-connection-indicator.connected {
        background: var(--primary-strong);
        box-shadow: 0 0 0 2px rgba(39,103,73,0.2);
    }

    .mobile-connection-indicator.disconnected {
        background: #e53e3e;
        box-shadow: 0 0 0 2px rgba(229,62,62,0.2);
    }

    @media (max-width:920px) {
        .connection-status {
            display: none;
        }

        .mobile-connection-indicator {
            display: block;
        }

        .bottom-nav {
            padding-top: 20px;
        }
    }

    /* Валидация акцизов */
    .accise-item.valid {
        border: 2px solid #2f9d3a;
    }

    .accise-item.invalid {
        border: 2px solid #e53e3e;
    }

    /* === ADDED: Mobile top header and burger menu === */
    .mb-header {
        display: none;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        background: var(--card);
        box-shadow: var(--shadow-sm);
        border-radius: 12px;
        margin-bottom: 12px;
        position: sticky;
        top: 0;
        z-index: 3000;
        width: 100%;
    }

    .mb-burger-btn {
        background: none;
        border: none;
        font-size: 22px;
        cursor: pointer;
        color: var(--text);
        line-height: 1;
        padding: 8px;
        border-radius: 8px;
        transition: var(--transition);
    }

    .mb-burger-btn:hover {
        background: rgba(39,103,73,0.08);
    }

    .mb-burger-menu {
        display: none;
        position: absolute;
        top: 60px;
        left: 12px;
        background: var(--card);
        border-radius: 12px;
        box-shadow: var(--shadow-sm);
        padding: 10px;
        width: 190px;
        flex-direction: column;
        gap: 8px;
        z-index: 3500;
    }

    .mb-burger-menu.show {
        display: flex;
    }

    .mb-burger-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
        color: var(--muted);
        transition: background var(--transition);
    }

    .mb-burger-item:hover {
        background: rgba(39,103,73,0.08);
        color: var(--primary-strong);
    }

    .mb-header .right {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    @media (max-width:920px) {
        .mb-header {
            display: flex;
        }
    }

    .nav .nav-item.extra {
        opacity: 0.9;
    }

    .page-section {
        display: none;
    }

    .page-section.show {
        display: block;
    }

    /* === Separators between nav sections on desktop === */
    .nav-separator {
        height: 1px;
        margin: 6px 0;
        background: rgba(15, 23, 36, 0.06);
        width: 100%;
    }

    /* === Mobile fixes === */
    @media (max-width: 920px) {
        #mbHeaderRight .mobile-connection-indicator {
            position: static !important;
            top: auto !important;
            left: auto !important;
            margin-right: 8px;
            display: inline-block;
        }
        
        .bottom-nav {
            padding-top: 8px !important;
            justify-content: space-between !important;
        }

        .bottom-nav .b-item {
            flex: 1 1 0;
            text-align: center;
        }
    }

    @media (min-width: 921px) {
        #bottomNav {
            display: none !important;
        }
    }

    @media (max-width: 920px) {
        #pageTitle {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: 600;
            color: var(--text);
            white-space: nowrap;
            pointer-events: none;
        }
    }

    @media (max-width: 920px) {
        header, .mb-header, .mobile-header {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        body {
            padding-top: 60px !important;
        }
    }

    @media (min-width: 921px) {
        nav, .sidebar, .tabs-left, .left-menu, .left-nav {
            position: fixed !important;
            top: 0;
            left: 0;
            height: 100vh;
            overflow-y: auto;
            background-color: var(--bg, #fff);
            z-index: 999;
        }
    }

    /* Красивое поле для ввода акцизов */
    #new-accise,
    #new-accise-mobile {
        padding: 12px 16px;
        border: 1px solid rgba(15, 23, 36, 0.08);
        border-radius: 14px;
        background-color: #fff;
        color: var(--text);
        font-size: 15px;
        font-weight: 500;
        box-shadow: 0 2px 6px rgba(12, 18, 24, 0.06);
        transition: all 0.25s ease;
        outline: none;
    }

    #new-accise:hover,
    #new-accise-mobile:hover {
        border-color: rgba(39, 103, 73, 0.2);
        box-shadow: 0 3px 10px rgba(12, 18, 24, 0.08);
    }

    #new-accise:focus,
    #new-accise-mobile:focus {
        border-color: var(--primary);
        box-shadow: 0 4px 14px rgba(39, 103, 73, 0.16);
    }

    @media (max-width: 920px) {
        #new-accise-mobile {
            flex: 1;
            min-width: 0;
            padding: 12px;
            font-size: 16px;
        }
        
        .mb-header {
            gap: 12px;
        }
        
        #new-accise-mobile {
            flex: 1 1 auto !important;
            max-width: none !important;
            margin: 0 12px !important;
        }
    }

    /* GIH summary styles */
    #gih-summary {
        margin: 8px 0;
        padding: 10px;
        cursor: pointer;
        transition: var(--transition);
    }

    #gih-summary:hover {
        background: rgba(0,0,0,0.03);
    }

    #gih-summary-title {
        font-weight: 600;
        font-size: 13px;
    }

    #gih-summary-list {
        transition: max-height 0.3s ease, opacity 0.2s ease;
        overflow: hidden;
    }

    #gih-summary.collapsed #gih-summary-list {
        max-height: 0;
        opacity: 0;
    }

    #gih-summary.expanded #gih-summary-list {
        max-height: 2000px;
        opacity: 1;
    }

    #gih-summary-arrow {
        transition: transform 0.25s ease;
    }

    #gih-summary.collapsed #gih-summary-arrow {
        transform: rotate(-90deg);
    }

    /* GIH Rooms Summary */
    #gih-rooms-summary {
        margin: 8px 0;
        padding: 10px;
        cursor: pointer;
        transition: var(--transition);
    }

    #gih-rooms-summary:hover {
        background: rgba(0,0,0,0.03);
    }

    #gih-rooms-summary-title {
        font-weight: 600;
        font-size: 13px;
    }

    #gih-rooms-summary-list {
        transition: max-height 0.3s ease, opacity 0.2s ease;
        overflow: hidden;
    }

    #gih-rooms-summary.collapsed #gih-rooms-summary-list {
        max-height: 0;
        opacity: 0;
    }

    #gih-rooms-summary.expanded #gih-rooms-summary-list {
        max-height: 2000px;
        opacity: 1;
    }

    #gih-rooms-summary-arrow {
        transition: transform 0.25s ease;
    }

    #gih-rooms-summary.collapsed #gih-rooms-summary-arrow {
        transform: rotate(-90deg);
    }

    .room-chip {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(15,23,36,0.08);
        background: var(--card);
        font-size: 13px;
        cursor: pointer;
        transition: box-shadow 0.18s ease, background 0.18s ease, color 0.18s ease;
    }

    .room-chip:hover {
        background: rgba(39,103,73,0.08);
    }

    .room-chip.saved {
        background: var(--primary);
        color: #fff;
        border-color: var(--primary-strong);
    }

    @keyframes gihCardFlash {
        0% { box-shadow: 0 0 0 3px var(--primary); }
        100% { box-shadow: none; }
    }

    .gih-card.highlighted {
        animation: gihCardFlash 0.8s ease-out;
    }

    #gih-sort-btn {
        padding: 4px 6px;
        min-width: auto;
        width: 28px;
        height: 28px;
    }

    #gih-sort-btn i {
        margin: 0;
    }

    /* Сброс лишних отступов */
    @media (max-width: 920px) {
        main, .content, .extra-section, .page-container, #main-content {
            margin-left: 0 !important;
        }
    }

    @media (min-width: 921px) {
        main, .content, .extra-section, .page-container, #main-content {
            margin-left: calc(220px + 24px) !important;
        }
    }

    .t-added { color: #064e17; }
    .t-here { color: #044a6a; }
    .t-out { color: #333; }
    .t-miss { color: #6b0b0b; }

    .gih-card {
        margin-bottom: 12px;
    }

    .history-date-header {
        font-weight: 700;
        margin: 15px 0 8px 0;
        padding-bottom: 5px;
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }

    #history-current-date:hover {
        background: rgba(0,0,0,0.05);
    }

    #history-date-picker {
        position: absolute;
        opacity: 0;
        pointer-events: none;
    }

    #history-prev-day,
    #history-next-day {
        min-width: 32px !important;
        width: 32px;
        height: 32px;
        padding: 6px !important;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #history-prev-day i,
    #history-next-day i {
        font-size: 12px;
        margin: 0;
    }

    #history-current-date {
        flex: 1;
        text-align: center;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        padding: 8px;
        border-radius: 8px;
        background: rgba(0,0,0,0.03);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        transition: background-color 0.2s ease;
        min-width: 0;
    }

    #history-current-date:hover {
        background: rgba(0,0,0,0.05);
    }

    @media (max-width: 480px) {
        #history-current-date {
            font-size: 13px;
            padding: 6px;
        }

        #history-prev-day,
        #history-next-day {
            min-width: 28px !important;
            width: 28px;
            height: 28px;
        }
    }

    #history-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 12px;
        margin-top: 12px;
    }

    #history-list .gih-card {
        position: relative;
        overflow: hidden;
    }

    #history-list.search-active {
        display: flex !important;
        flex-direction: column !important;
        gap: 12px;
        margin-top: 12px;
    }

    /* GIH products columns layout */
    .gih-products-columns {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        margin-bottom: 8px;
    }

    .gih-column {
        flex: 1;
        min-width: 0;
    }

    .gih-column-title {
        font-weight: 600;
        margin: 6px 0;
    }

    .gih-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
    }

    @media (max-width:900px) {
        .gih-products-columns {
            flex-direction: column;
        }

        .gih-row {
            justify-content: flex-start;
        }
    }

    @media (min-width: 921px) {
        .product-btn {
        min-width: 80px !important;
        padding: 6px 8px !important;
        padding-right: 26px !important;
        font-size: 13px !important;
    }
    .product-count {
        width: 18px;
        height: 18px;
        font-size: 10px;
    }

        .gih-column-title {
            font-size: 13px;
            margin-bottom: 4px;
        }

        .gih-row {
            gap: 6px;
        }
    }

    #gih-saved-records .muted,
    #history-list .muted {
        line-height: 1 !important;
        font-weight: 900;
    }

    /* Accordion styles */
    .accordion {
        border-radius: 12px;
        overflow: hidden;
    }

    .accordion-item {
        border-bottom: 1px solid rgba(0,0,0,0.1);
    }

    .accordion-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 14px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s ease;
    }

    .accordion-header:hover {
        background: rgba(39,103,73,0.06);
    }

    .accordion-header i {
        transition: transform 0.25s ease;
    }

    .accordion-header.active i {
        transform: rotate(90deg);
    }

    .accordion-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding-left: 14px;
    }

    .accordion-content.open {
        max-height: 1000px;
        padding-bottom: 8px;
    }

    .accordion-subitem {
        padding: 8px 0 8px 16px;
        font-size: 14px;
        color: #444;
    }

    /* Печать */
    @media print {
        nav, .nav, .sidebar, .left-menu, .left-nav,
        .mb-header, .mobile-header,
        .bottom-nav, #print-history-btn, #bottomNav, #history-search-btn, #history-next-day, #history-prev-day {
            display: none !important;
        }

        main, .content, .page-container, #main-content {
            margin: 0 !important;
            padding: 0 !important;
            width: 100% !important;
        }

        #history-current-date {
            font-size: 20px !important;
            background: #fff !important;
        }

        body {
            background: #fff !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        .card {
            box-shadow: none !important;
        }

        .gih-card {
            box-shadow: none !important;
            border: 1px solid #ccc !important;
            margin-bottom: 6px !important;
        }

        .gih-card * {
            font-size: 16px !important;
            line-height: 1.2 !important;
            color: #000 !important;
        }

        .history-date-header {
            margin: 8px 0 4px 0 !important;
            padding-bottom: 2px !important;
            border-bottom: 1px solid #ccc !important;
            font-size: 16px !important;
        }

        .status-1, .status-2, .status-3, .status-4,
        .t-added, .t-here, .t-out, .t-miss {
            background: transparent !important;
            color: #000 !important;
            border: none !important;
            line-height: 2 !important;
        }
    }


    /* Улучшенные анимации для всех элементов */
    .btn, .product-btn, .room-item, .gih-product, .nav-item, 
    .b-item, .mb-burger-item, .accordion-header, .room-chip,
    .mode-btn, .card, .gih-card {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    }

    /* Убираем трансформации при наведении */
    .btn:hover, .product-btn:hover, .room-item:hover, 
    .gih-product:hover, .card:hover {
        transform: none !important;
    }

    /* Анимация появления для элементов */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .card, .room-item, .gih-card {
        animation: fadeInUp 0.6s ease-out;
    }

    /* Задержки для анимации */
    .room-item:nth-child(odd) { animation-delay: 0.1s; }
    .room-item:nth-child(even) { animation-delay: 0.2s; }
    .gih-card:nth-child(odd) { animation-delay: 0.1s; }
    .gih-card:nth-child(even) { animation-delay: 0.2s; }
    .card, .room-item, .gih-card {
        animation: none !important;
    }

    /* Упрощаем анимацию появления */
    @keyframes simpleFadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .modal {
        animation: simpleFadeIn 0.3s ease !important;
    }

    /* Отключаем анимации для пользователей, которые их предпочитают не использовать */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
/* === КАСТОМНЫЙ КАЛЕНДАРЬ === */
.custom-calendar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(10, 12, 18, 0.36);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    padding: 20px;
}

.custom-calendar-overlay.show {
    display: flex;
}

.custom-calendar {
    background: var(--card);
    border-radius: var(--radius);
    box-shadow: var(--shadow-sm);
    width: 100%;
    max-width: 320px;
    padding: 16px;
    animation: simpleFadeIn 0.3s ease;
}

.custom-calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.custom-calendar-title {
    font-weight: 600;
    font-size: 16px;
    color: var(--text);
}

.custom-calendar-nav {
    display: flex;
    gap: 4px;
}

.custom-calendar-nav-btn {
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(39, 103, 73, 0.1);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--primary-strong);
    transition: var(--transition);
}

.custom-calendar-nav-btn:hover {
    background: rgba(39, 103, 73, 0.2);
}

.custom-calendar-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 2px;
    margin-bottom: 8px;
}

.custom-calendar-weekday {
    text-align: center;
    font-size: 12px;
    font-weight: 600;
    color: var(--muted);
    padding: 8px 0;
}

.custom-calendar-days {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 2px;
}

.custom-calendar-day {
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text);
    transition: var(--transition);
    position: relative;
}

.custom-calendar-day:hover {
    background: rgba(39, 103, 73, 0.1);
}

.custom-calendar-day.other-month {
    color: var(--muted);
    opacity: 0.4;
}

.custom-calendar-day.today {
    background: rgba(39, 103, 73, 0.15);
    color: var(--primary-strong);
    font-weight: 600;
}

.custom-calendar-day.today::after {
    content: '';
    position: absolute;
    bottom: 2px;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 4px;
    background: var(--primary-strong);
    border-radius: 50%;
}

.custom-calendar-day.selected {
    background: var(--primary);
    color: white;
    font-weight: 600;
}

.custom-calendar-day.selected::after {
    display: none;
}

.custom-calendar-day.disabled {
    color: var(--muted);
    opacity: 0.3;
    cursor: not-allowed;
}

.custom-calendar-day.disabled:hover {
    background: transparent;
}

/* Стиль для счетчика записей (просто число) */
.day-record-count {
    position: absolute;
    top: 3px;
    right: 3px;
    font-size: 9px;
    color: var(--accent);
    font-weight: 700;
}

.custom-calendar-footer {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(15, 23, 36, 0.1);
}

/* Адаптация для мобильных */
@media (max-width: 480px) {
    .custom-calendar {
        max-width: 280px;
        padding: 12px;
    }
    
    .custom-calendar-day {
        height: 32px;
        font-size: 13px;
    }
    
    .custom-calendar-nav-btn {
        width: 28px;
        height: 28px;
    }
    
    .day-record-count {
        font-size: 8px;
    }
}

/* Скрываем нативный календарь при открытии кастомного */
body.custom-calendar-open input[type="date"] {
    opacity: 0;
    position: absolute;
    pointer-events: none;
}

@media (max-width: 920px) {.desktop-only{display:none!important;}}

#dispatchers-roomsGrid {
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.dispatchers-floor-section {
    padding: 12px;
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.6));
    box-shadow: 0 3px 10px rgba(12,18,24,0.04);
    border: 1px solid rgba(15,23,36,0.05);
}
.dispatchers-floor-title {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 10px;
    color: var(--primary-strong);
}
.dispatchers-room-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}
.dispatchers-room-item {
    min-width: 72px;
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid rgba(15,23,36,0.08);
    background: rgba(15,23,36,0.02);
    text-align: center;
    cursor: pointer;
    font-weight: 700;
    transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease, background 0.15s ease, color 0.15s ease;
    user-select: none;
}

.dispatchers-room-item:hover {
    box-shadow: 0 6px 12px rgba(12,18,24,0.12);
}
.dispatchers-room-item.selected {
    background: rgba(39,103,73,0.16);
    color: #215c40;
    border-color: rgba(39,103,73,0.35);
}
.dispatchers-room-item.excluded {
    background: rgba(220,53,69,0.12);
    color: #c12a35;
    border-color: rgba(220,53,69,0.32);
}
    .dispatchers-room-item.on-arrival {
        background: rgba(39,103,73,0.14);
        color: #1b5c33;
        border-color: rgba(39,103,73,0.35);
    }
.dispatchers-room-item.found {
    position: relative;
    border-width: 2px;
    border-color: rgba(39,103,73,0.55);
    background: rgba(39,103,73,0.06);
}
.dispatchers-room-item.found.selected {
    border-color: rgba(39,103,73,0.8);
    background: rgba(39,103,73,0.14);
    color: #1b5c33;
}

.dispatchers-stats {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
    padding: 15px;
    background: rgba(39,103,73,0.05);
    border-radius: 10px;
}

.dispatchers-stat-item {
    text-align: center;
}

.dispatchers-stat-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-strong);
    line-height: 1;
    margin-bottom: 5px;
}

.dispatchers-stat-label {
    font-size: 12px;
    color: var(--muted);
    font-weight: 500;
}

.dispatchers-error {
    color: #e53e3e;
    background: rgba(229,62,62,0.1);
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
    border-left: 3px solid #e53e3e;
}

.dispatchers-success {
    color: var(--primary-strong);
    background: rgba(39,103,73,0.1);
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
    border-left: 3px solid var(--primary);
}

.dispatchers-loading {
    color: var(--primary);
    text-align: center;
    padding: 20px;
}

.dispatchers-room-item.found.selected {
    background: var(--primary) !important;
    color: #fff !important;
    border-color: var(--primary-strong) !important;
}

/* Стили для автоматически загружаемых номеров из беседы */
#dispatchers-today-rooms {
    margin-top: 16px;
}

#dispatchers-today-rooms-status {
    margin-top: 8px;
    font-size: 14px;
    color: var(--muted);
}

#dispatchers-today-rooms-list {
    margin-top: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

/* Стили для группировки по этажам */
#dispatchers-today-rooms-list.floor-mode {
    display: block;
    flex-direction: column;
}

#dispatchers-today-rooms-list.floor-mode > .dispatchers-floor-section {
    width: 100%;
    margin-bottom: 16px;
    display: block;
}

#dispatchers-today-rooms-list.floor-mode > .dispatchers-floor-section:last-child {
    margin-bottom: 0;
}

/* Стили для списка пустых номеров */
#emptied-rooms-list {
    margin-top: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

/* Стили для группировки по этажам */
#emptied-rooms-list.floor-mode {
    display: block;
    flex-direction: column;
}

#emptied-rooms-list.floor-mode > .dispatchers-floor-section {
    width: 100%;
    margin-bottom: 16px;
    display: block;
}

#emptied-rooms-list.floor-mode > .dispatchers-floor-section:last-child {
    margin-bottom: 0;
}

.dispatchers-today-room-card {
    min-width: 72px;
    max-width: 72px;
    width: 72px;
    min-height: 50px;
    padding: 10px;
    border-radius: 10px;
    border: 1px solid rgba(15,23,36,0.08);
    background: rgba(15,23,36,0.02);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    text-align: center;
    font-weight: 700;
    flex-shrink: 0;
}

.dispatchers-today-room-number {
    font-weight: 700;
    font-size: 16px;
    color: var(--text);
    text-align: center;
    user-select: none;
}

.dispatchers-today-room-time {
    font-size: 10px;
    color: var(--accent);
    font-weight: 700;
    position: absolute;
    right: 3px;
    bottom: 3px;
    user-select: none;
}

/* Значок опустошения (∅) в левом нижнем углу карточки номера */
.dispatchers-today-room-empty {
    font-size: 10px;
    color: var(--muted);
    font-weight: 700;
    position: absolute;
    left: 3px;
    bottom: 3px;
    user-select: none;
}

/* Обводка для номеров из загруженного PDF в списке "Уже проверено" */
.dispatchers-today-room-card.found {
    border: 2px solid var(--primary);
    box-shadow: 0 0 0 2px rgba(39,103,73,0.2);
}

.dispatchers-today-rooms-error {
    color: #c00;
    background: rgba(229,62,62,0.1);
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
    border-left: 3px solid #e53e3e;
}

/* Стили для переключателя "Разделить на двоих" */
.toggle-switch {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    margin-left: 10px;
}

.toggle-switch input {
    display: none;
}

.toggle-slider {
    width: 44px;
    height: 22px;
    background: #ccc;
    border-radius: 24px;
    position: relative;
    transition: 0.3s;
    border: 1px solid rgba(15,23,36,0.1);
    display: flex;
    align-items: center;
}

.toggle-knob {
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    position: absolute;
    transition: 0.3s;
    left: 1px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    /* Центрируем вертикально */
    top: 50%;
    transform: translateY(-50%);
}

.toggle-switch input:checked + .toggle-slider {
    background: var(--primary);
    border-color: var(--primary-strong);
}

.toggle-switch input:checked + .toggle-slider .toggle-knob {
    transform: translateX(22px) translateY(-50%);
}

.toggle-switch:hover .toggle-slider {
    background: #b3b3b3;
}

.toggle-switch input:checked:hover + .toggle-slider {
    background: var(--primary-strong);
}

.toggle-switch span {
    font-size: 13px;
    font-weight: 500;
    color: var(--text);
    white-space: nowrap;
}
/* Адаптация для мобильной версии депатчеров */
/* Compact controls for dispatchers header (mobile) */
@media (max-width: 920px) {
  /* контейнер в заголовке */
  .dispatchers-header-row {
    display: flex;
    align-items: center;
    gap: 8px;
    justify-content: flex-end;
    flex: 1;
  }

  /* компактное поле ввода */
  #dispatchers-room-input-mobile {
    max-width: 110px !important;
    min-width: 80px;
    padding: 6px 8px !important;
    font-size: 13px !important;
    border-radius: 8px !important;
    line-height: 1;
  }

  /* иконки-кнопки */
  .icon-btn {
    width: 34px;
    height: 34px;
    padding: 0;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 14px;
  }

  /* стиль основной кнопки (чек) */
  .icon-btn:not(.ghost) {
    background: var(--primary);
    color: #fff;
  }

  /* ghost / вторичная кнопка */
  .icon-btn.ghost {
    background: transparent;
    border: 1px solid rgba(15,23,36,0.06);
    color: var(--text);
  }

  

  /* если заголовок слишком длинный — скрывать переполнение */
  #dispatchers-section > div[style] > div:first-child {
    max-width: 50%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
}


/* Десктопная версия */
@media (min-width: 921px) {
    .mobile-only {
        display: none !important;
    }
    
    .desktop-only {
        display: block !important;
    }
}

.bottom-line{
width: 100%;
min-height: 18px;
}
.copy-text{
    background-color: transparent; 
    border: none; 
    cursor: pointer; 
}
.copy-text:hover{
    background-color: transparent; 
    border: none; 
    cursor: pointer;
    text-decoration-line: underline;
    }
</style>
</head>
<body>
    <div>
<div class="app">
<!-- LEFT NAV (desktop) -->
<nav aria-hidden="false" class="nav">
<div class="logo"><i class="fas fa-wine-bottle" style="padding-right:10px;"></i>Минибары</div>
<div class="nav-item active" data-tab="accises"><i class="fas fa-file-invoice"></i><span>Акцизы</span></div>
<div class="nav-item" data-tab="dispatchers"><i class="fas fa-file-pdf"></i><span>Депатчеры</span></div>
<div class="nav-item" data-tab="sroki"><i class="fas fa-door-closed"></i><span>Сроки</span></div>
<div class="nav-item" data-tab="history"><i class="fas fa-history"></i><span>История</span></div>
<div class="nav-item" data-tab="gih"><i class="fas fa-users"></i><span>GIH</span></div>
<div class="nav-separator"></div>
<!-- ADDED: extra desktop tabs (above connection status) -->
<div class="nav-item extra" data-tab="emptied"><i class="fas fa-box-open"></i><span>Пустые</span></div>
<div class="nav-item extra" data-tab="calculator"><i class="fas fa-calculator"></i><span>Калькулятор</span></div>
<div class="nav-item extra" data-tab="learning"><i class="fas fa-book-open"></i><span>Обучение</span></div>
<div class="nav-item extra" data-tab="settings"><i class="fas fa-cog"></i><span>Настройки</span></div>
<div class="nav-separator"></div>
<!-- Desktop connection status -->
<div class="connection-status disconnected" id="connectionStatus">
<span class="dot"></span>
<span class="text">Соединение...</span>
</div><div id="accise-input-container" style="margin-top:12px; display:flex; gap:10px; align-items:center;"><input class="input" id="new-accise" placeholder="Введите акциз ..."/></div>
</nav>
<main class="content" id="main-content">
<!-- ADDED: Mobile top header (burger + sync) -->
<div class="mb-header" id="mbHeader">
<button aria-label="Открыть меню" class="mb-burger-btn" id="mbBurgerBtn">☰</button><input class="input" id="new-accise-mobile" placeholder="Введите акциз ..." style="max-width:160px; margin-left:10px;"/>
<div class="right" id="mbHeaderRight">
<!-- сюда перенесём #mobileConnectionIndicator на мобильной ширине -->
</div>
<div class="mb-burger-menu" id="mbBurgerMenu" role="menu">
    <div class="mb-burger-item" data-tab="emptied"><i class="fas fa-box-open"></i><span>Пустые</span></div>
    <div class="mb-burger-item" data-tab="calculator"><i class="fas fa-calculator"></i><span>Калькулятор</span></div>
    <div class="mb-burger-item" data-tab="learning"><i class="fas fa-book-open"></i><span>Обучение</span></div>
    <div class="mb-burger-item" data-tab="settings"><i class="fas fa-cog"></i><span>Настройки</span></div>
</div>
</div>
<div class="card" id="accises-section">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div>
<div style="font-weight:700; font-size:16px">Акцизы</div>
</div>
<div class="row">
<div class="muted">Всего: <strong id="total-accises">0</strong></div>
<div class="muted">Символов: <strong id="total-chars">0</strong></div>
<button class="btn ghost small" id="copy-accises" title="Копировать все валидные акцизы"><i class="fas fa-copy"></i></button>
</div>
</div>
<div id="accises-list" style="margin-top:12px;"></div>
<div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
</div>
</div>
<div class="card hidden" id="sroki-section">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div style="font-weight:700; font-size:16px">Сроки</div>
<div class="row desktop-only" style="gap:12px; align-items:center;">
<span id="deadlines-selected-count" style="font-size:13px; color:var(--muted); display:none;">Выбрано номеров: <strong id="deadlines-selected-number">0</strong></span>
<button class="btn ghost small" id="deadlines-select-mode-btn" title="Режим выбора номеров"><i class="fas fa-check-square"></i> Выбрать номера</button>
<button class="btn ghost small" id="deadlines-print-btn" title="Печать выбранных номеров" style="display:none;"><i class="fas fa-print"></i> Печать</button>
<button class="btn small" id="deadlines-stats-btn" title="Статистика по номерам Сроки"><i class="fas fa-chart-pie"></i> Статистика</button>
<button class="btn ghost small" id="deadlines-reset-btn" title="Сбросить все номера"><i class="fas fa-undo"></i></button>
</div>
<div class="row mobile-only" style="gap:8px; align-items:center; justify-content:flex-end;">
<button class="btn small" id="deadlines-stats-btn-mobile" title="Статистика по номерам Сроки"><i class="fas fa-chart-pie"></i> Статистика</button>
<button class="btn ghost small" id="deadlines-reset-btn-mobile" title="Сбросить все номера"><i class="fas fa-undo"></i></button>
</div>
</div>
<div class="rooms-grid" id="rooms-grid"></div>
</div>
<div class="card hidden" id="gih-section">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div id="gih-title-date" style="font-weight:700; font-size:16px">GIH</div>
<div class="row"><button class="btn ghost small desktop-only" disabled="True" id="print-gih-btn" title="Печать GIH"><i class="fas fa-print"></i></button>
<button class="btn ghost small" id="gih-sort-btn" title="Сортировать"><i class="fas fa-sort-numeric-down"></i></button>
<button class="btn small" id="add-gih-btn"><i class="fas fa-plus"></i> Новая запись</button>
</div>
</div>
<div aria-hidden="true" class="gih-form" id="gih-form">
<div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
<input class="input" id="gih-room" placeholder="Номер комнаты" style="width:140px"/>
<div style="flex:1">
<div class="gih-products-area" id="gih-products-area"></div>
</div>
</div>
<div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
<button class="btn ghost small" id="cancel-gih">Отмена</button>
<button class="btn small" id="save-gih">Сохранить</button>
</div>
</div>
<div class="card" id="gih-summary" style="margin:8px 0;  padding:10px; cursor:pointer;">
<div class="gih-summary-header" style="display:flex; justify-content:space-between; align-items:center;">
<div id="gih-summary-title" style="font-weight:600; font-size:13px;">Список продуктов</div>
<svg height="16" id="gih-summary-arrow" viewbox="0 0 24 24" width="16">
<path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</div>
<div class="muted" id="gih-summary-list" style="font-size:12px; line-height:1.35; margin-top:6px;"></div>
</div>
<div class="card" id="gih-rooms-summary" style="margin:8px 0; padding:10px; cursor:pointer;">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div id="gih-rooms-summary-title">Список номеров (<span id="rooms-saved-count">0</span>/<span id="rooms-total-count">0</span>)</div>
<svg height="16" id="gih-rooms-summary-arrow" viewbox="0 0 24 24" width="16">
<path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</div>
<div class="muted" id="gih-rooms-summary-list" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; font-size:12px; line-height:1.35;"></div>
</div>
<div class="gih-records" id="gih-records"></div><div class="muted" id="gih-summary-list" style="font-size:14px; line-height:1.6;"></div>
<hr id="gih-divider" style="display:none; margin:20px 0; border:none; border-top:1px solid rgba(0,0,0,0.1);"/>
<div class="gih-records" id="gih-saved-records"></div>
</div>
<!-- ==== Настройки ==== -->
<div class="card hidden" id="settings-section">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div style="font-weight:700; font-size:16px">Настройки приложения</div>
</div>
<div style="margin-top:15px;">
<p>Здесь появятся настройки:</p>
<ul style="margin:10px 0 0 20px">
<li>Синхронизация</li>
<li>Внешний вид</li>
<li>Управление данными</li>
<li>Резервное копирование</li>
</ul>
</div>
</div>
<!-- ==== Обучение ==== -->
<div class="card hidden" id="learning-section">
<div style="display:flex; justify-content:space-between; align-items:center;">
<div style="font-weight:700; font-size:16px">Обучение</div>
</div>
<div style="margin-top:15px;">
<div class="accordion">
<!-- Введение -->
<div class="accordion-item">
<div class="accordion-header">1. Введение <i class="fas fa-chevron-right"></i></div>
<div class="accordion-content">
<div class="accordion-subitem">1.1 Знакомство с отелем</div>
<div class="accordion-subitem">1.2 Стандарты обслуживания</div>
<div class="accordion-subitem">1.3 Основные обязанности</div>
</div>
</div>
<!-- Детали работы -->
<div class="accordion-item">
<div class="accordion-header">2. Детали работы <i class="fas fa-chevron-right"></i></div>
<div class="accordion-content">
<div class="accordion-subitem">2.1 Порядок обхода номеров</div>
<div class="accordion-subitem" style="padding-left:28px;">2.1.1 Arrivals</div>
<div class="accordion-subitem" style="padding-left:28px;">2.1.2 Departures</div>
<div class="accordion-subitem" style="padding-left:28px;">2.1.3 GIH</div>
<div class="accordion-subitem">2.2 Проверка минибара</div>
<div class="accordion-subitem" style="padding-left:28px;">2.2.1 Продукция</div>
<div class="accordion-subitem" style="padding-left:28px;">2.2.2 Расположение продуктов</div>
<div class="accordion-subitem" style="padding-left:28px;">2.2.3 Порядок проверки</div>
<div class="accordion-subitem">2.3 Сканирование акциз</div>
<div class="accordion-subitem">2.4 Контроль сроков годности</div>
</div>
</div>
<!-- Приложение -->
<div class="accordion-item">
<div class="accordion-header">3. Приложение <i class="fas fa-chevron-right"></i></div>
<div class="accordion-content">
<div class="accordion-subitem">3.1 Акцизы</div>
<div class="accordion-subitem">3.2 Сроки</div>
<div class="accordion-subitem">3.3 GIH</div>
</div>
</div>
</div>
</div>
</div>
<!-- ==== История ==== -->
<div class="card hidden" id="history-section">
<!-- Заголовок + поиск -->
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
<div style="font-weight:700; font-size:16px">История</div><div class="row" style="align-items:center; gap:6px;"><div id="history-search-wrapper" style="display:flex; align-items:center; gap:6px;">
<button class="btn ghost small" id="history-search-clear" style="display:none; min-width:32px; height:32px; padding:0; display:inline-flex; align-items:center; justify-content:center;">
<i class="fas fa-times"></i>
</button>
<input id="history-search-input" placeholder="Номер" style="width:0; opacity:0; transition:width .25s, opacity .25s; border:1px solid rgba(0,0,0,.1); border-radius:8px; padding:0 8px; height:32px; font-size:14px;" type="text"/>
<button class="btn ghost small" id="history-search-btn" style="min-width:32px; height:32px; padding:0; display:inline-flex; align-items:center; justify-content:center;" title="Поиск">
<i class="fas fa-search"></i>
</button>
</div><button class="btn ghost small desktop-only" id="print-history-btn" title="Печать"><i class="fas fa-print"></i></button></div>
<!-- Блок поиска -->
</div>
<!-- Контроллер даты -->
<div id="history-date-row" style="display:flex; align-items:center; justify-content:space-between; margin-bottom:15px; gap:8px; width: 100%;">
<button class="btn ghost small" id="history-prev-day" style="min-width:32px; padding:6px;">
<i class="fas fa-chevron-left" style="font-size:12px;"></i>
</button>
<div id="history-current-date" style="flex:1; text-align:center; font-weight:600; font-size:14px; cursor:pointer; padding:8px; border-radius:8px; background:rgba(0,0,0,0.03); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
<!-- текст даты вставится скриптом -->
</div>
<button class="btn ghost small" disabled="" id="history-next-day" style="min-width:32px; padding:6px;">
<i class="fas fa-chevron-right" style="font-size:12px;"></i>
</button>
</div>
<!-- Список записей -->
<div id="history-list"></div>
</div>
<!-- ==== Депатчеры ==== -->
<!-- ==== Депатчеры ==== -->
<div class="card hidden" id="dispatchers-section">
    <!-- Заголовок и кнопка выбора файла (для десктопной версии) -->
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 12px;">
        <div style="font-weight:700; font-size:16px">Депатчеры</div>
        <!-- Кнопка сортировки (для всех версий) -->
        <divstyle="display:flex; gap:8px; align-items:center;">
            <button class="mobile-only btn ghost small" id="dispatchers-sort-toggle" style="white-space: nowrap;">
                <i class="fas fa-sort"></i> <span id="dispatchers-sort-label">По времени</span>
            </button>
            <!-- Кнопка выбора файла только для десктопной версии -->
            <div class="desktop-only" style="display:flex; gap:8px; align-items:center;">
                <input type="file" id="dispatchers-pdfFile" accept=".pdf" style="display:none;"/>
                <span id="dispatchers-fileName" class="muted" style="font-size:13px; margin-right:8px;"></span>
                <button class="btn" id="dispatchers-selectFileBtn"><i class="fas fa-upload"></i> Выбрать файл</button>
            </div>
        
    </div>
    
    <!-- Инструкции (только для десктопной версии) -->
    <div class="desktop-only">
        <div class="instructions" style="background:rgba(39,103,73,0.08); padding:15px; border-radius:10px; margin-bottom:15px;">
            <h3 style="margin:0 0 10px 0; font-size:14px; font-weight:600;">Инструкция:</h3>
            <ol style="margin:0; padding-left:20px; font-size:13px; line-height:1.6;">
                <li>Выгрузите депатчеры в Opera и сохраните файл в папке 04 MB</li>
                <li>Нажмите кнопку "Выбрать файл" и выберите файл OperaPrint.pdf</li>
                <li>В результатах: один клик - исключить жилой номер, двойной клик - пометить номер на заезд</li>
                <li>Нажмите "Выгрузить депатчеры" для печати итогового списка</li>
            </ol>
            <div class="file-path" style="font-family:monospace; background:rgba(15,23,36,0.06); padding:8px; border-radius:8px; margin-top:12px; font-size:12px;">
                <div style="margin-bottom: 8px; font-weight: 600;">Путь к файлу:</div>
                <button class="copy-text onclick="copyText('G:\\Food and Beverage\\F&B Service\\Outlets\\Room Service\\04 MB\\OperaPrint.pdf')">
                    G:\Food and Beverage\F&B Service\Outlets\Room Service\04 MB\OperaPrint.pdf
                  </button>
            </div>
        </div>
    </div>
    
    
    <!-- Автоматически загружаемые номера из беседы -->
        <div class="card" style="margin-bottom:15px;" id="dispatchers-today-rooms">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 12px;">
        <div id="dispatchers-today-rooms-title" style="font-weight:600; font-size:14px; padding:12px;">Уже проверено (0):</div>
        <button class="desktop-only btn ghost small" id="dispatchers-sort-toggle-mobile" style="white-space: nowrap;">
            <i class="fas fa-sort"></i> <span id="dispatchers-sort-label-mobile">По времени</span>
        </button>
        </div>
        <div id="dispatchers-today-rooms-status">Загрузка текущего списка...</div>
        <div id="dispatchers-today-rooms-list"></div>
    </div>
    
    <!-- Таблица номеров комнат (только для мобильной версии, скрыта) -->
    <div class="mobile-only" style="display:none;">
        <div style="font-weight:600; font-size:14px; margin-bottom:10px;">Таблица номеров комнат</div>
        <div id="dispatchers-roomsGrid"></div>
    </div>
    
    <!-- Счетчик выделенных номеров для десктопной версии (уже есть в selection-controls) -->
    
    <!-- Кнопки обработки (только для десктопной версии) -->
    <div class="desktop-only">
        <div class="card" id="dispatchers-result">
            <p class="muted" style="text-align:center; padding:20px;">Результаты появятся здесь после обработки файла.</p>
        </div>
    </div>
</div>
<!-- ==== Пустые (отдельная вкладка) ==== -->
<div class="card hidden" id="emptied-section">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 12px;">
        <div style="font-weight:700; font-size:16px">Пустые</div>
        <div class="row" style="gap:8px; align-items:center;">
            <div class="muted" style="font-size:13px;">Всего: <strong id="emptied-total-count">0</strong></div>
            <button class="btn ghost small" id="emptied-sort-toggle" style="white-space: nowrap;">
                <i class="fas fa-sort"></i> <span id="emptied-sort-label">По времени</span>
            </button>
        </div>
    </div>
    <div id="emptied-status" style="margin-bottom:12px; color:var(--muted); font-size:13px;">Загрузка списка пустых номеров...</div>
    <div id="emptied-rooms-list"></div>
</div>
<!-- ==== Калькулятор (отдельная вкладка) ==== -->
<div class="card" id="calculator-section" class="hidden">
<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
<div style="font-weight:700; font-size:16px">Калькулятор</div>
<div class="row" style="gap:10px; align-items:center;">
<div class="muted" style="font-size:14px;">Итого: <strong id="calc-total">0 ₽</strong></div>
<button class="btn ghost small" id="calc-reset">Сбросить</button>
</div>
</div>
<div id="calc-chips" class="products-wrap" style="max-height:none;"></div>
<div style="margin-top:12px;">
<div style="font-weight:600; font-size:14px; margin-bottom:6px;">Выбрано</div>
<div id="calc-selected" class="muted" style="font-size:13px; line-height:1.6;"></div>
</div>
</div>
<!-- MOBILE: bottom navigation duplicate (visible on small screens) -->
<div aria-hidden="true" class="bottom-nav" id="bottomNav">
<!-- Mobile connection indicator -->
<div class="mobile-connection-indicator disconnected" id="mobileConnectionIndicator"></div>
<div class="b-item active" data-tab="accises" title="Акцизы"><i class="fas fa-file-invoice"></i><div class="b-label">Акцизы</div></div>
<div class="b-item" data-tab="dispatchers" title="Депатчеры"><i class="fas fa-list"></i><div class="b-label">Депатчеры</div></div>
<div class="b-item" data-tab="sroki" title="Сроки"><i class="fas fa-door-closed"></i><div class="b-label">Сроки</div></div>
<div class="b-item" data-tab="history" title="История"><i class="fas fa-history"></i><div class="b-label">История</div></div>
<div class="b-item" data-tab="gih" title="GIH"><i class="fas fa-users"></i><div class="b-label">GIH</div></div>
</div>
<!-- Modal (rooms) -->
<div aria-hidden="true" class="overlay" id="modal">
<div aria-modal="true" class="modal" role="dialog">
<div class="modal-head">
<div>
<div class="modal-title" style="font-weight:700">Номер <span id="modal-room">—</span></div>
<div class="muted">Выберите продукты</div>
</div>
<div>
<button aria-label="Закрыть" class="btn ghost small" id="modal-close"><i class="fas fa-times"></i></button>
</div>
</div>
<div class="products-wrap" id="modal-products"></div>
<div class="modal-foot" style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
<button class="btn ghost small" id="modal-reset">Сброс</button>
<button class="btn secondary small" id="modal-ok-order">Сроки в порядке</button>
<button class="btn small" id="modal-save"><i class="fas fa-check"></i> Завершить</button>
</div>
</div>
</div>
</div>
<div aria-hidden="true" class="overlay" id="deadlines-stats-modal">
<div aria-modal="true" class="modal" role="dialog">
<div class="modal-head">
<div>
<div class="modal-title" style="font-weight:700">Статистика сроков</div>
<div class="muted" style="font-size:12px;">Текущие статусы номеров и продуктов</div>
</div>
<div>
<button aria-label="Закрыть" class="btn ghost small" id="deadlines-stats-close"><i class="fas fa-times"></i></button>
</div>
</div>
<div id="deadlines-stats-content" style="display:flex; flex-direction:column; gap:16px;">
<div style="display:flex; gap:12px; flex-wrap:wrap;">
<div class="card" style="flex:1; min-width:160px; padding:12px;">
<div class="muted" style="font-size:12px;">Номеров в порядке</div>
<div style="font-size:24px; font-weight:700;color:#1b7a2b" id="deadlines-count-ok">0</div>
</div>
<div class="card" style="flex:1; min-width:160px; padding:12px;">
<div class="muted" style="font-size:12px;">Номеров заменить</div>
<div style="font-size:24px; font-weight:700; color:#c12a35;" id="deadlines-count-products">0</div>
</div>
<div class="card" style="flex:1; min-width:160px; padding:12px;">
<div class="muted" style="font-size:12px;">Осталось проверить</div>
<div style="font-size:24px; font-weight:700;" id="deadlines-count-neutral">0</div>
</div>
</div>
<div class="card" style="padding:12px;">
<div style="font-weight:600; margin-bottom:8px;">Статистика по продуктам</div>
<div class="muted" style="font-size:12px; margin-bottom:8px;">Суммарное количество продуктов с истекающим сроком</div>
<div id="deadlines-products-stats" style="display:flex; flex-wrap:wrap; gap:8px; font-size:13px;"></div>
</div>
</div>
</div>
</div>
<script>
    function copyText(textToCopy) {
      navigator.clipboard.writeText(textToCopy)
    }
    </script>
<script>
                // ===== FIREBASE CONFIGURATION =====
                // ЗАМЕНИТЕ НА СВОЮ КОНФИГУРАЦИЮ FIREBASE
                const firebaseConfig = {
                    apiKey: "AIzaSyCcVgoGZ6MnjQOghbYRmnvITPU-O-zDYao",
                    authDomain: "minibars-17502.firebaseapp.com",
                    databaseURL: "https://minibars-17502-default-rtdb.firebaseio.com",
                    projectId: "minibars-17502",
                    storageBucket: "minibars-17502.firebasestorage.app",
                    messagingSenderId: "464067936838",
                    appId: "1:464067936838:web:f6c37ecf3ec4ae5d598047"
                };

                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);
                const database = firebase.database();

                // Firebase connection status
                function updateConnectionStatus(connected) {
                    const statusEl = document.getElementById('connectionStatus');
                    const mobileIndicator = document.getElementById('mobileConnectionIndicator');

                    if (connected) {
                        if (statusEl) {
                            statusEl.classList.remove('disconnected');
                            statusEl.classList.add('connected');
                            statusEl.querySelector('.text').textContent = 'Синхронизировано';
                        }
                        if (mobileIndicator) {
                            mobileIndicator.classList.remove('disconnected');
                            mobileIndicator.classList.add('connected');
                        }
                    } else {
                        if (statusEl) {
                            statusEl.classList.remove('connected');
                            statusEl.classList.add('disconnected');
                            statusEl.querySelector('.text').textContent = 'Оффлайн';
                        }
                        if (mobileIndicator) {
                            mobileIndicator.classList.remove('connected');
                            mobileIndicator.classList.add('disconnected');
                        }
                    }
                }

                // Listen for connection status changes
                firebase.database().ref('.info/connected').on('value', (snapshot) => {
                    updateConnectionStatus(snapshot.val() === true);
                });

                /* ==== data & config ==== */
                const appData = {
                    accises: [],
                    rooms: [],
                    selectedRoom: null,
                    roomProducts: {
                        standard: ['twix', 'pepper', 'redbull', 'cola', 'baikal', 'borjomi', 'apple', 'tomato', 'corona', 'stella'],
                        lux: ['twix', 'redbull', 'orange', 'cherry', 'apple', 'tomato', 'borjomi', 'cola', 'stella', 'corona']
                    },
                    gihRecords: [],
                    gihHistory: [],
                    products: {
                        twix: 'Твикс', jager: 'Ягер', gin: 'Джин', rum: 'Ром', cognac: 'Коньяк',
                        whiskey: 'Виски', vodka: 'Водка', pepper: 'Пеппер', redbull: 'Ред Булл',
                        cola: 'Кола', baikal: 'Байкал', borjomi: 'Боржоми', white_wine: 'Белое вино',
                        red_wine: 'Красное вино', apple: 'Яблоко', tomato: 'Томат', corona: 'Корона',
                        stella: 'Стелла', gancha: 'Ганча', martini: 'Мартини', orange: 'Апельсин',
                        cherry: 'Вишня', loriot: 'Лориот', whiskey02: 'Виски 0.2'
                    },
                    roomsList: [500, 502, 504, 506, 508, 509, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 600, 602, 604, 606, 608, 609, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 700, 702, 704, 706, 708, 709, 710, 712, 714, 716, 717, 718, 720, 722, 724, 725, 726, 728, 730, 732, 734, 800, 802, 804, 806, 808, 809, 810, 812, 814, 816, 817, 818, 820, 822, 824, 825, 826, 828, 830, 832, 834, 900, 902, 904, 906, 908, 909, 910, 912, 914, 916, 917, 918, 920, 922, 924, 925, 926, 928, 930, 932, 934, 1000, 1002, 1004, 1006, 1008, 1009, 1010, 1012, 1014, 1016, 1017, 1018, 1020, 1022, 1024, 1025, 1026, 1028, 1030, 1032, 1034, 1100, 1102, 1104, 1106, 1108, 1109, 1110, 1112, 1114, 1116, 1117, 1118, 1120, 1122, 1124, 1125, 1126, 1128, 1130, 1132, 1134, 1200, 1202, 1204, 1206, 1208, 1209, 1210, 1212, 1214, 1216, 1217, 1218, 1220, 1222, 1224, 1225, 1226, 1228, 1230, 1232, 1234, 1300, 1302, 1304, 1306, 1308, 1309, 1310, 1312, 1314, 1316, 1317, 1318, 1320, 1322, 1324, 1325, 1326, 1328, 1330, 1332, 1334, 1400, 1402, 1404, 1406, 1408, 1409, 1410, 1412, 1414, 1416, 1417, 1418, 1420, 1422, 1424, 1425, 1426, 1428, 1430, 1432, 1434, 1500, 1502, 1504, 1506, 1508, 1509, 1510, 1512, 1514, 1516, 1517, 1518, 1520, 1522, 1524, 1525, 1526, 1528, 1530, 1532, 1534, 1600, 1602, 1604, 1606, 1608, 1609, 1610, 1612, 1614, 1616, 1617, 1618, 1620, 1622, 1624, 1625, 1626, 1628, 1630, 1632, 1634, 1700, 1702, 1704, 1706, 1708, 1709, 1710, 1712, 1714, 1716, 1717, 1718, 1720, 1722, 1724, 1725, 1726, 1728, 1730, 1732, 1734, 1800, 1802, 1804, 1806, 1807, 1808, 1810, 1811, 1812, 1814, 1816, 1818, 1902, 1904, 1906, 1908, 1910, 1911, 1912, 1914, 1916, 1918, 1919, 1920],
                    dispatchersSelectedRooms: []
                };

                // Emoji map for product buttons
                const PRODUCT_EMOJIS = {
                    twix: "🍫",
                    jager: "🦌",
                    gin: "🍸",
                    rum: "🏴‍☠️",
                    cognac: "🥃",
                    whiskey: "🥃",
                    whiskey02: "🥃",
                    vodka: "🍶",
                    pepper: "🌶️",
                    redbull: "⚡",
                    cola: "🥤",
                    baikal: "💧",
                    borjomi: "🫧",
                    white_wine: "🥂",
                    red_wine: "🍷",
                    corona: "🍺",
                    stella: "🍺",
                    gancha: "🍹",
                    martini: "🍸",
                    loriot: "🍾",
                    apple: "🍏",
                    tomato: "🍅",
                    orange: "🍊",
                    cherry: "🍒"
                };



                // Флаг для предотвращения повторной отрисовки
                let isRendering = false;

                /* Which products have multi-select limits */
                const MULTI_LIMITS = {
                    jager: 2,
                    gin: 2,
                    vodka: 2,
                    whiskey: 3,
                    pepper: 2,
                    redbull: 2,
                    cola: 2,
                    baikal: 2,
                    borjomi: 2
                };

                const $ = s => document.querySelector(s);
                const $$ = s => Array.from(document.querySelectorAll(s));

                /* Firebase synchronization */
                let isUpdatingFromFirebase = false;

                // Save data to Firebase
                async function saveToFirebase() {
    if (isUpdatingFromFirebase) return;
    
    try {
        // Всегда сохраняем в localStorage
        localStorage.setItem('hotelMinibarData', JSON.stringify(appData));
        
        // Безопасное сохранение в Firebase с мержем истории
        // 1) читаем текущую историю на сервере
        const serverSnap = await database.ref('minibarData/gihHistory').once('value');
        const serverHistory = Array.isArray(serverSnap.val()) ? serverSnap.val() : (serverSnap.val() || []);
        const localHistory = Array.isArray(appData.gihHistory) ? appData.gihHistory : (appData.gihHistory || []);
        
        // 2) объединяем по id (уникальные записи)
        const byId = new Map();
        [...serverHistory, ...localHistory].forEach(item => {
            if (item && item.id != null && !byId.has(item.id)) byId.set(item.id, item);
        });
        const mergedHistory = Array.from(byId.values());
        
        // 3) готовим итоговые данные к сохранению
        const dataToSave = { ...appData, gihHistory: mergedHistory };
        
        // 4) сохраняем целиком, но уже с объединённой историей
        await database.ref('minibarData').set(dataToSave);
        console.log('Данные (с объединённой историей) сохранены в Firebase и localStorage');
    } catch (error) {
        console.error('Ошибка сохранения в Firebase (данные остались в localStorage):', error);
        // Данные остаются в localStorage даже при ошибке Firebase
    }
}

                // Load data from Firebase
                async function loadFromFirebase() {
                    try {
                        const snapshot = await database.ref('minibarData').once('value');
                        const data = snapshot.val();

                        if (data) {
                            isUpdatingFromFirebase = true;
                            Object.assign(appData, data);
                            localStorage.setItem('hotelMinibarData', JSON.stringify(appData));
                            isUpdatingFromFirebase = false;

                            // Update UI
                            updateUIFromData();
                        }
                    } catch (error) {
                        console.error('Error loading from Firebase:', error);
                    }
                }

                // Listen for real-time updates from Firebase
                function setupFirebaseListener() {
    database.ref('minibarData').on('value', (snapshot) => {
        const data = snapshot.val();
        
        if (data && !isUpdatingFromFirebase) {
            console.log('Получены обновления из Firebase');
            isUpdatingFromFirebase = true;
            
            // Сохраняем текущую историю на случай конфликта
            const currentHistory = appData.gihHistory || [];
            
            Object.assign(appData, data);
            
            // Восстанавливаем историю если новая версия её потеряла
            if (currentHistory.length > 0 && (!appData.gihHistory || appData.gihHistory.length < currentHistory.length)) {
                console.log('Восстанавливаем историю из локальной копии');
                appData.gihHistory = currentHistory;
            }
            
            localStorage.setItem('hotelMinibarData', JSON.stringify(appData));
            isUpdatingFromFirebase = false;
            
            updateUIFromData();
        }
    });
}

                // Update UI when data changes
                function updateUIFromData() {
                    // Сортируем продукты по исходному порядку из appData.products
                    if (appData.products && typeof appData.products === 'object') {
                        const originalOrder = [
                            "twix", "jager", "gin", "rum", "cognac", "whiskey", "vodka", "pepper",
                            "redbull", "cola", "baikal", "borjomi", "white_wine", "red_wine", "apple",
                            "tomato", "corona", "stella", "gancha", "martini", "orange", "cherry",
                            "loriot", "whiskey02"
                        ];

                        appData.products = Object.fromEntries(
                            Object.entries(appData.products).sort((a, b) => {
                                const ia = originalOrder.indexOf(a[0]);
                                const ib = originalOrder.indexOf(b[0]);
                                // Если ключ есть в оригинале — сортируем по позиции, иначе в конец
                                if (ia === -1 && ib === -1) return a[1].localeCompare(b[1], 'ru');
                                if (ia === -1) return 1;
                                if (ib === -1) return -1;
                                return ia - ib;
                            })
                        );
                    }
                    renderHistory();
                    if (isRendering) return;
                    isRendering = true;
                    appData.gihRecords.forEach(r => normalizeRecordProducts(r));
                    const accisesList = $('#accises-list');
accisesList.innerHTML = '';

// Рендерим акцизы в правильном порядке (последние добавленные - сверху)
const accisesToRender = [...(appData.accises || [])];
accisesToRender.forEach(renderAcciseItem);
                    updateAcciseStats();
                    appData.rooms = appData.rooms || [];
                    renderRooms();
                    // restore GIH sort direction from localStorage before first render
                    try {
                        const savedDir = localStorage.getItem('gihSortDirection') ?? localStorage.getItem('gihSortAsc');
                        if (savedDir !== null) {
                            let dir = savedDir;
                            try { dir = JSON.parse(savedDir); } catch (e) { }
                            if (dir === 'asc' || dir === 'desc') {
                                gihSortAsc = (dir === 'asc');
                            } else if (typeof dir === 'boolean') {
                                gihSortAsc = dir;
                            } else if (savedDir === '1' || savedDir === '0' || savedDir === 'true' || savedDir === 'false') {
                                gihSortAsc = (savedDir === '1' || savedDir === 'true');
                            }
                        }
                        const sortBtnInit = document.querySelector('#gih-sort-btn');
                        if (sortBtnInit) {
                            sortBtnInit.innerHTML = gihSortAsc ? '<i class="fas fa-sort-numeric-down"></i>'
                                : '<i class="fas fa-sort-numeric-up"></i>';
                        }
                    } catch (e) { }
                    renderAllGIHRecords();
                    updateGIHSummary();

                    updateGIHRoomsSummary();
                    
    renderDispatchersRooms();
                    isRendering = false;
                }

                /* debounce save */
                let saveTimer;
                function persistLocalSnapshot() {
                    try {
                        localStorage.setItem('hotelMinibarData', JSON.stringify(appData));
                    } catch (e) {
                        console.warn('Не удалось сохранить данные в localStorage', e);
                    }
                }
                function saveDebounced() {
                    persistLocalSnapshot();
                    clearTimeout(saveTimer);
                    saveTimer = setTimeout(() => {
                        persistLocalSnapshot();
                        saveToFirebase();
                    }, 200);
                }

                let isPushingRoomsRealtime = false;
                let roomsRealtimeRef = null;
                function pushRoomsRealtime() {
                    if (!database || typeof database.ref !== 'function') return;
                    try {
                        const payload = JSON.parse(JSON.stringify(appData.rooms || []));
                        isPushingRoomsRealtime = true;
                        database
                            .ref('minibarData/rooms')
                            .set(payload)
                            .then(() => { isPushingRoomsRealtime = false; })
                            .catch(error => {
                                console.error('Ошибка сохранения номеров в Firebase (реальное время):', error);
                                isPushingRoomsRealtime = false;
                            });
                    } catch (error) {
                        console.warn('Не удалось отправить номера в Firebase (реальное время):', error);
                        isPushingRoomsRealtime = false;
                    }
                }

                function setupRoomsRealtimeListener() {
                    if (!database || typeof database.ref !== 'function') return;
                    if (roomsRealtimeRef) return;
                    roomsRealtimeRef = database.ref('minibarData/rooms');
                    roomsRealtimeRef.on('value', snapshot => {
                        const remoteRooms = snapshot.val();
                        if (!Array.isArray(remoteRooms)) return;
                        if (isPushingRoomsRealtime) return;

                        const localSerialized = JSON.stringify(appData.rooms || []);
                        const remoteSerialized = JSON.stringify(remoteRooms);
                        if (localSerialized === remoteSerialized) return;

                        appData.rooms = remoteRooms.map(room => {
                            if (!room || typeof room !== 'object') return room;
                            const copy = { ...room };
                            if (!copy.products || typeof copy.products !== 'object') copy.products = {};
                            copy.deadlinesStatus = copy.deadlinesStatus || (hasSelectedDeadlineProducts(copy) ? DEADLINE_STATUS.PRODUCTS : DEADLINE_STATUS.NEUTRAL);
                            return copy;
                        });

                        persistLocalSnapshot();
                        renderRooms();

                        if (currentDeadlineRoomNumber != null) {
                            const current = appData.rooms.find(r => r && r.number === currentDeadlineRoomNumber);
                            if (current) {
                                deadlineModalState = {
                                    products: JSON.parse(JSON.stringify(current.products || {})),
                                    status: current.deadlinesStatus || DEADLINE_STATUS.NEUTRAL,
                                    type: current.type
                                };
                                renderDeadlineProducts(current);
                                updateModalOkButton();
                            }
                        }
                    });
                }

                /* status title */
                function statusTitle(s) {
                    switch (Number(s)) { case 1: return 'Пополнено'; case 2: return 'На месте'; case 3: return 'Выложили'; case 4: return 'Не пополнено'; default: return 'Нейтральный'; }
                }


                // ====== Авто-очистка старых GIH-карточек (удаление также из Firebase) ======

                // Проверка, совпадает ли дата с сегодняшней (локальная)
                function _gih_isSameLocalDay(iso) {
                    if (!iso) return false;
                    const d = new Date(iso);
                    if (isNaN(d.getTime())) return false;
                    const now = new Date();
                    return d.getFullYear() === now.getFullYear() &&
                        d.getMonth() === now.getMonth() &&
                        d.getDate() === now.getDate();
                }

                // Удаление старых карточек из массива и Firebase
                function cleanupOldGIHRecords() {
                    if (!Array.isArray(appData.gihRecords) || appData.gihRecords.length === 0) return 0;
                    const before = appData.gihRecords.length;
                    const keep = [];
                    appData.gihRecords.forEach(rec => {
                        if (!rec) return;
                        const ts = rec.createdAt || rec.updatedAt || rec.savedAt;
                        if (!ts || _gih_isSameLocalDay(ts)) {
                            keep.push(rec);
                        } else {
                            try { firebase.database().ref("gihRecords/" + rec.id).remove(); } catch (e) { console.warn(e); }
                        }
                    });
                    appData.gihRecords = keep;
                    const removed = before - keep.length;
                    if (removed > 0) {
                        try { saveDebounced(); } catch (e) { }
                        try { renderAllGIHRecords(); } catch (e) { }
                        console.info("[GIH cleanup] removed", removed, "old records");
                    }
                    return removed;
                }

                // Планировщик на ежедневную очистку
                function scheduleGIHDailyCleanup() {
                    try {
                        const now = new Date();
                        const next = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 2);
                        const ms = next - now;
                        setTimeout(function tick() {
                            cleanupOldGIHRecords();
                            setInterval(cleanupOldGIHRecords, 24 * 60 * 60 * 1000);
                        }, Math.max(0, ms));
                    } catch (e) {
                        console.warn('scheduleGIHDailyCleanup failed', e);
                    }
                }
                /* ===== ACCISES (same) ===== */
                function initAccises() {
                    const bindAcciseInput = (el) => {
                        if (!el) return;
                        let t;
                        el.addEventListener('input', () => {
                            clearTimeout(t);
                            t = setTimeout(() => {
                                addAccise(el.value);
                                el.value = '';
                            }, 350);
                        });
                        el.addEventListener('keydown', e => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                clearTimeout(t);
                                addAccise(el.value);
                                el.value = '';
                            }
                        });
                    };
                    bindAcciseInput($('#new-accise'));
                    bindAcciseInput($('#new-accise-mobile'));
                    $('#copy-accises').addEventListener('click', () => {
                        const v = (appData.accises || []).filter(a => a.isValid).map(a => a.text);
                        if (v.length === 0) {
                            alert("Список пуст");
                            return;
                        }

                        // Разворачиваем массив и объединяем строки
const textToCopy = v.slice().reverse().join('\n');

function doCopy(callback) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(textToCopy)
      .then(() => {
        alert('Скопировано');
        if (callback) callback();
      })
      .catch(() => {
        fallbackCopy(textToCopy);
        if (callback) callback();
      });
  } else {
    fallbackCopy(textToCopy);
    if (callback) callback();
  }
}

                        if (confirm("Очистить список акциз после копирования?")) {
                            doCopy(() => {
                                appData.accises = [];
                                document.querySelector('#accises-list').innerHTML = '';
                                updateAcciseStats();
                                saveDebounced();
                            });
                        } else {
                            doCopy();
                        }
                    });


                    function fallbackCopy(text) {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        try {
                            document.execCommand('copy');
                            alert('Скопировано');
                        } catch (err) {
                            alert('Ошибка копирования');
                        }
                        document.body.removeChild(textarea);
                    }
                }
                function convertLayout(t) {
                    const rus = 'йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ';
                    const eng = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM';
                    const rusFull = 'йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,';
                    const engFull = 'qwertyuiop[]asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>?';

                    // Определяем раскладку по первому буквенному символу
                    let isRussian = false;
                    let isEnglish = false;

                    // Ищем первую букву в тексте
                    for (let i = 0; i < t.length; i++) {
                        const ch = t[i];
                        if (rus.includes(ch)) {
                            isRussian = true;
                            break;
                        } else if (eng.includes(ch)) {
                            isEnglish = true;
                            break;
                        }
                    }

                    // Если русская раскладка - конвертируем, иначе оставляем как есть
                    if (isRussian) {
                        return t.split('').map(ch => {
                            const i = rusFull.indexOf(ch);
                            return i > -1 ? engFull[i] : ch;
                        }).join('');
                    }

                    return t;
                }
                function addAccise(text) {
                    if (!text || !text.trim()) return; const parts = text.split(/[\s\n]+/).filter(Boolean); parts.forEach(p => {
                        const conv = convertLayout(p);
                        // Проверка на дубликаты
                        if (appData.accises.some(x => x.text === conv)) {
                            alert("Такой акциз уже добавлен");
                            return;
                        } const isValid = conv.length >= 20 && /^\d/.test(conv); const item = { id: Date.now() + Math.random(), text: conv, isValid, ts: new Date().toISOString() }; appData.accises.unshift(item); saveDebounced();
                        updateUIFromData();
                    }); updateAcciseStats();
                }


                function renderAcciseItem(a) {
                    const list = document.querySelector('#accises-list');
                    // Avoid duplicates
                    if (list.querySelector(`[data-id="${a.id}"]`)) return;

                    const el = document.createElement('div');
                    el.className = 'accise-item ' + (a.isValid ? 'valid' : 'invalid');
                    el.dataset.id = a.id;
                    el.style = 'position:relative; box-sizing:border-box; padding:12px 44px 28px 12px; border-radius:10px; margin-bottom:8px; background:var(--card); min-height:64px;';

                    el.innerHTML = `
                                            <button class="btn ghost small accise-remove" title="Удалить"
                                                    style="position:absolute; top:8px; right:8px; width:28px; height:28px; padding:0; display:inline-flex; align-items:center; justify-content:center;">
                                                <i class="fas fa-trash"></i>
                                            </button>

                                            <div class="accise-content" style="word-break:break-word; overflow-wrap:anywhere; padding-right:8px;">
                                                <div class="text" style="font-weight:600; white-space:normal;">${a.text}</div>
                                            </div>

                                            <div class="accise-footer" style="position:absolute; left:12px; bottom:8px;">
                                                <small class="muted">${new Date(a.ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</small>
                                            </div>
                                        `;

                    // Delete handler
                    el.querySelector('.accise-remove').addEventListener('click', () => {
                        appData.accises = appData.accises.filter(x => x.id !== a.id);
                        el.remove();
                        updateAcciseStats();
                        saveDebounced();
                    });

                    list.appendChild(el);
                }
                function updateAcciseStats() { $('#total-accises').textContent = appData.accises.length; $('#total-chars').textContent = appData.accises.reduce((s, i) => s + (i.text ? i.text.length : 0), 0); }

                /* ===== ROOMS & MODAL (deadlines) ===== */
                const DEADLINE_STATUS = {
                    NEUTRAL: 'neutral',
                    PRODUCTS: 'products',
                    OK: 'ok'
                };
                let currentDeadlineRoomNumber = null;
    let deadlineModalState = null;
    let deadlinesStatsModalOpen = false;
    let deadlinesSelectMode = false;
    let deadlinesSelectedRooms = new Set();

    function resetAllDeadlines() {
    if (!confirm("Вы уверены, что хотите очистить все сроки? Это действие нельзя отменить.")) {
        return;
    }
    
    // Сбрасываем все номера
    (appData.rooms || []).forEach(room => {
        if (room) {
            room.products = {};
            room.deadlinesStatus = DEADLINE_STATUS.NEUTRAL;
        }
    });
    
    // Сбрасываем выбранные номера если есть
    deadlinesSelectedRooms.clear();
    updateDeadlinesSelectedCount();
    
    // Обновляем интерфейс
    renderRooms();
    saveDebounced();
    pushRoomsRealtime();
    
    // Закрываем модальное окно если открыто
    if (currentDeadlineRoomNumber != null) {
        closeModal();
    }
    
    // Обновляем статистику если открыта
    updateDeadlinesStatsIfOpen();
    
    alert("Все сроки очищены!");
}
function toggleFloorSelection(floorNumber) {
    const floorRooms = (appData.rooms || []).filter(r => r && r.floor === floorNumber);
    if (!floorRooms.length) return;

    // Проверяем, выбраны ли уже все номера этого этажа (сравниваем как строки)
    const allSelected = floorRooms.every(r => deadlinesSelectedRooms.has(String(r.number)));

    // Переключаем состояние (всегда работаем со строками!)
    floorRooms.forEach(r => {
        const numStr = String(r.number);
        if (allSelected) {
            deadlinesSelectedRooms.delete(numStr);
        } else {
            deadlinesSelectedRooms.add(numStr);
        }
    });

    // 🔸 Обновляем счётчик и интерфейс
    updateDeadlinesSelectedCount();
    renderRooms();
}


                function initSroki() {
                    renderRooms();
                    const overlay = $('#modal');
                    $('#modal-close').addEventListener('click', closeModal);
                    overlay.addEventListener('click', e => {
                        if (e.target === overlay) closeModal();
                    });

                    const saveBtn = $('#modal-save');
                    if (saveBtn) {
                        saveBtn.innerHTML = '<i class="fas fa-check"></i> Сохранить';
                        saveBtn.addEventListener('click', saveDeadlineProducts);
                    }

                    const okBtn = $('#modal-ok-order');
                    if (okBtn) okBtn.addEventListener('click', markDeadlinesOk);

                    const resetSelectBtn = $('#modal-reset');
                    if (resetSelectBtn) resetSelectBtn.addEventListener('click', resetDeadlineSelections);

                    const statsBtn = $('#deadlines-stats-btn');
                    if (statsBtn) statsBtn.addEventListener('click', openDeadlinesStatsModal);
                    const statsBtnMobile = $('#deadlines-stats-btn-mobile');
                    if (statsBtnMobile) statsBtnMobile.addEventListener('click', openDeadlinesStatsModal);

                    const selectModeBtn = $('#deadlines-select-mode-btn');
                    if (selectModeBtn) selectModeBtn.addEventListener('click', toggleDeadlinesSelectMode);

                    const printBtn = $('#deadlines-print-btn');
                    if (printBtn) printBtn.addEventListener('click', printDeadlinesSelected);

                    const statsOverlay = $('#deadlines-stats-modal');
                    if (statsOverlay) {
                        statsOverlay.addEventListener('click', e => {
                            if (e.target === statsOverlay) closeDeadlinesStatsModal();
                        });
                    }
                    const statsClose = $('#deadlines-stats-close');
                    if (statsClose) statsClose.addEventListener('click', closeDeadlinesStatsModal);
                    const resetBtn = $('#deadlines-reset-btn');
    const resetBtnMobile = $('#deadlines-reset-btn-mobile');
    
    if (resetBtn) resetBtn.addEventListener('click', resetAllDeadlines);
    if (resetBtnMobile) resetBtnMobile.addEventListener('click', resetAllDeadlines);
                    
                }
                function groupRoomsByFloorForDeadlines(rooms = []) {
                    const floors = {};
                    rooms.forEach(rawNum => {
                        const roomStr = String(rawNum);
                        const floorKey = roomStr.length === 3 ? roomStr.charAt(0) : roomStr.substring(0, 2);
                        if (!floors[floorKey]) floors[floorKey] = [];
                        floors[floorKey].push(Number(rawNum));
                    });
                    return floors;
                }
                function ensureRoomRecord(num) {
                    appData.rooms = appData.rooms || [];
                    let room = appData.rooms.find(r => r.number === num);
                    if (!room) {
                        const isLux = (num % 2 === 1) || num === 1818 || String(num).endsWith('00') || String(num).endsWith('34');
                        room = {
                            number: num,
                            type: isLux ? 'lux' : 'standard',
                            completed: false,
                            completedAt: null,
                            products: {},
                            deadlinesStatus: DEADLINE_STATUS.NEUTRAL
                        };
                        appData.rooms.push(room);
                    } else {
                        if (!room.products || typeof room.products !== 'object') {
                            room.products = {};
                        }
                        if (!room.deadlinesStatus) {
                            if (typeof room.deadlinesOk === 'boolean') {
                                room.deadlinesStatus = room.deadlinesOk ? DEADLINE_STATUS.OK : DEADLINE_STATUS.NEUTRAL;
                            } else if (hasSelectedDeadlineProducts(room)) {
                                room.deadlinesStatus = DEADLINE_STATUS.PRODUCTS;
                            } else {
                                room.deadlinesStatus = DEADLINE_STATUS.NEUTRAL;
                            }
                        }
                    }
                    delete room.deadlinesOk;
                    return normalizeRoomDeadlineStatus(room);
                }
                function hasSelectedDeadlineProducts(room) {
                    if (!room || !room.products) return false;
                    return Object.values(room.products).some(count => Number(count) > 0);
                }
                function formatDeadlineProducts(room) {
                    const entries = Object.entries(room.products || {}).filter(([, count]) => Number(count) > 0);
                    if (entries.length === 0) return '';
                    return entries.map(([key, count]) => {
                        const name = appData.products[key] || key;
                        return count > 1 ? `${name} (x${count})` : name;
                    }).join(', ');
                }
                function floorLabelFromKey(key) {
                    const numeric = Number(key);
                    if (Number.isFinite(numeric)) return `${numeric} этаж`;
                    return `${key} этаж`;
                }
                function updateModalOkButton() {
                    const btn = $('#modal-ok-order');
                    if (!btn) return;
                    btn.innerHTML = '<i class="fas fa-check"></i> Сроки в порядке';
                    if (deadlineModalState && deadlineModalState.status === DEADLINE_STATUS.OK) {
                        btn.classList.add('deadlines-applied');
                    } else {
                        btn.classList.remove('deadlines-applied');
                    }
                }
                function renderDeadlineProducts(room) {
                    const container = $('#modal-products');
                    if (!container || !room || !deadlineModalState) return;
                    container.innerHTML = '';
                    const keys = appData.roomProducts[room.type] || [];
                    if (keys.length === 0) {
                        const emptyHint = document.createElement('div');
                        emptyHint.className = 'muted';
                        emptyHint.style.fontSize = '13px';
                        emptyHint.textContent = 'Нет продуктов для этого типа номера';
                        container.appendChild(emptyHint);
                        return;
                    }
                    keys.forEach(productKey => {
                        const displayName = appData.products[productKey] || productKey;
                        const emoji = (typeof PRODUCT_EMOJIS !== 'undefined' && PRODUCT_EMOJIS[productKey]) ? PRODUCT_EMOJIS[productKey] : '';
                        const btn = document.createElement('button');
                        btn.className = 'product-btn';
                        btn.dataset.product = productKey;

                        const textSpan = document.createElement('span');
                        textSpan.className = 'btn-text';
                        textSpan.textContent = emoji ? `${emoji} ${displayName}` : displayName;
                        btn.appendChild(textSpan);

                        const countSpan = document.createElement('span');
                        countSpan.className = 'product-count';
                        const count = deadlineModalState.products[productKey] || 0;
                        if (count > 0) {
                            btn.classList.add('active');
                            countSpan.textContent = count;
                        }
                        btn.appendChild(countSpan);

                        btn.addEventListener('click', () => toggleDeadlineSelection(productKey));
                        container.appendChild(btn);
                    });
                }
                function toggleDeadlineSelection(productKey) {
                    if (!deadlineModalState) return;
                    const max = MULTI_LIMITS[productKey] || 1;
                    const current = deadlineModalState.products[productKey] || 0;
                    const next = (current + 1) % (max + 1);
                    if (next === 0) {
                        delete deadlineModalState.products[productKey];
                    } else {
                        deadlineModalState.products[productKey] = next;
                    }
                    if (Object.keys(deadlineModalState.products).length > 0) {
                        deadlineModalState.status = DEADLINE_STATUS.PRODUCTS;
                    } else if (deadlineModalState.status !== DEADLINE_STATUS.OK) {
                        deadlineModalState.status = DEADLINE_STATUS.NEUTRAL;
                    }
                    const room = ensureRoomRecord(currentDeadlineRoomNumber);
                    renderDeadlineProducts(room);
                    updateModalOkButton();
                }
                function saveDeadlineProducts() {
                    if (currentDeadlineRoomNumber == null || !deadlineModalState) {
                        closeModal();
                        return;
                    }
                    const room = ensureRoomRecord(currentDeadlineRoomNumber);
                    const hasProducts = Object.keys(deadlineModalState.products).length > 0;
                    const nextStatus = hasProducts ? DEADLINE_STATUS.PRODUCTS : DEADLINE_STATUS.NEUTRAL;
                    commitDeadlineChanges(room, deadlineModalState.products, nextStatus);
                    closeModal();
                }
                function markDeadlinesOk() {
                    if (currentDeadlineRoomNumber == null) return;
                    const room = ensureRoomRecord(currentDeadlineRoomNumber);
                    commitDeadlineChanges(room, {}, DEADLINE_STATUS.OK);
                    closeModal();
                }
                function resetDeadlineSelections() {
                    if (!deadlineModalState) return;
                    deadlineModalState.products = {};
                    deadlineModalState.status = DEADLINE_STATUS.NEUTRAL;
                    const room = ensureRoomRecord(currentDeadlineRoomNumber);
                    renderDeadlineProducts(room);
                    updateModalOkButton();
                }
                function commitDeadlineChanges(room, products, status) {
                    room.products = JSON.parse(JSON.stringify(products || {}));
                    room.deadlinesStatus = status;
                    normalizeRoomDeadlineStatus(room);
                    saveDebounced();
                    renderRooms();
                    pushRoomsRealtime();
                    updateDeadlinesStatsIfOpen();
                }
                function renderRooms() {
                    const grid = $('#rooms-grid');
                    if (!grid) return;
                    grid.innerHTML = '';
                    const roomsList = Array.isArray(appData.roomsList) ? appData.roomsList.slice() : [];
                    if (roomsList.length === 0) {
                        grid.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">Номера не найдены</div>';
                        return;
                    }
                    const floors = groupRoomsByFloorForDeadlines(roomsList);
                    const sortedFloors = Object.keys(floors).sort((a, b) => {
                        const ai = parseInt(a, 10);
                        const bi = parseInt(b, 10);
                        const aNaN = Number.isNaN(ai);
                        const bNaN = Number.isNaN(bi);
                        if (aNaN && bNaN) return a.localeCompare(b, 'ru');
                        if (aNaN) return 1;
                        if (bNaN) return -1;
                        return ai - bi;
                    });
                    sortedFloors.forEach(floorKey => {
                        const section = document.createElement('div');
                        section.className = 'deadlines-floor-section';
                        const title = document.createElement('div');
title.className = 'deadlines-floor-title';
title.textContent = floorLabelFromKey(floorKey);

// 🔸 Добавляем обработчик клика — выбрать/снять все номера этого этажа
// Заменить существующий title.addEventListener('click', ...) на этот код:
title.addEventListener('click', () => {
    // Только в режиме выбора номеров
    if (!deadlinesSelectMode) return;

    // Получаем номера этажа из того же объекта floors, что использует renderRooms()
    const roomsOnFloor = Array.isArray(floors[floorKey]) ? floors[floorKey].slice() : [];
    if (roomsOnFloor.length === 0) {
        console.warn('toggleFloorSelection: нет номеров на этаже', floorKey);
        return;
    }

    // Приводим к строкам для корректного сравнения с Set
    const roomsOnFloorStr = roomsOnFloor.map(n => String(n));

    // Проверяем, выбраны ли все (строковое сравнение)
    const allSelected = roomsOnFloorStr.every(numStr => deadlinesSelectedRooms.has(numStr));

    // Лог для отладки — убрать позже
    console.debug('toggleFloorSelection', { floorKey, roomsOnFloorStr, allSelected, beforeCount: deadlinesSelectedRooms.size });

    // Переключаем: если все выбраны — удаляем, иначе добавляем
    if (allSelected) {
        roomsOnFloorStr.forEach(numStr => deadlinesSelectedRooms.delete(numStr));
    } else {
        roomsOnFloorStr.forEach(numStr => deadlinesSelectedRooms.add(numStr));
    }

    // Обновляем счётчик и отрисовку
    updateDeadlinesSelectedCount();
    renderRooms();

    // Сохраняем выбор, если нужно (раскомментируй, если у тебя есть save-функция для этого)
    // if (typeof saveDeadlinesSelection === 'function') saveDeadlinesSelection();
    // или, если используется saveDebounced():
    // saveDebounced();

    // Лог для отладки — убрать позже
    console.debug('toggleFloorSelection after', { floorKey, afterCount: deadlinesSelectedRooms.size });
});

section.appendChild(title);

                        const list = document.createElement('div');
                        list.className = 'deadlines-room-list';
                        const roomsOnFloor = floors[floorKey].slice().sort((a, b) => a - b);
                        roomsOnFloor.forEach(num => {
                            const room = ensureRoomRecord(num);
                            const roomEl = document.createElement('div');
                            roomEl.className = 'deadlines-room-item';
                            const status = room.deadlinesStatus;
                            roomEl.classList.toggle('status-ok', status === DEADLINE_STATUS.OK);
                            roomEl.classList.toggle('status-alert', status === DEADLINE_STATUS.PRODUCTS);
                            roomEl.classList.toggle('status-empty', status === DEADLINE_STATUS.NEUTRAL);
                            roomEl.classList.toggle('selected', deadlinesSelectedRooms.has(String(room.number)));
                            roomEl.dataset.room = String(room.number);
                            const numberEl = document.createElement('div');
                            numberEl.className = 'deadlines-room-number';
                            numberEl.textContent = room.number;
                            const summary = formatDeadlineProducts(room);
                            roomEl.appendChild(numberEl);
                            if (status === DEADLINE_STATUS.PRODUCTS && summary) {
                                roomEl.title = summary;
                            } else if (status === DEADLINE_STATUS.OK) {
                                roomEl.title = 'Сроки в порядке';
                            } else {
                                roomEl.removeAttribute('title');
                            }
                            roomEl.addEventListener('click', () => {
                                if (deadlinesSelectMode) {
                                    toggleDeadlineRoomSelection(room.number);
                                } else {
                                    openDeadlineModal(room.number);
                                }
                            });
                            list.appendChild(roomEl);
                        });
                        section.appendChild(list);
                        grid.appendChild(section);
                    });
                    updateDeadlinesStatsIfOpen();
                }
                function normalizeRoomDeadlineStatus(room) {
                    if (!room) return { deadlinesStatus: DEADLINE_STATUS.NEUTRAL, products: {} };
                    const hasProducts = hasSelectedDeadlineProducts(room);

                    // Не понижаем статус OK, даже если есть продукты (для внешних сигналов типа "опустош")
                    if (room.deadlinesStatus === DEADLINE_STATUS.OK) {
                        return room;
                    }

                    if (room.deadlinesStatus === DEADLINE_STATUS.PRODUCTS && !hasProducts) {
                        room.deadlinesStatus = DEADLINE_STATUS.NEUTRAL;
                    } else if (!room.deadlinesStatus) {
                        room.deadlinesStatus = hasProducts ? DEADLINE_STATUS.PRODUCTS : DEADLINE_STATUS.NEUTRAL;
                    }
                    return room;
                }
                function openDeadlineModal(roomNumber) {
                    const room = ensureRoomRecord(roomNumber);
                    currentDeadlineRoomNumber = room.number;
                    appData.selectedRoom = room.number;
                    deadlineModalState = {
                        products: JSON.parse(JSON.stringify(room.products || {})),
                        status: room.deadlinesStatus || DEADLINE_STATUS.NEUTRAL,
                        type: room.type
                    };
                    if (deadlineModalState.status === DEADLINE_STATUS.OK && Object.keys(deadlineModalState.products).length > 0) {
                        deadlineModalState.status = DEADLINE_STATUS.PRODUCTS;
                    }
                    $('#modal-room').textContent = room.number;
                    const overlay = $('#modal');
                    overlay.classList.add('show');
                    overlay.style.display = 'flex';
                    const modalEl = overlay.querySelector('.modal');
                    modalEl.classList.add('show');
                    renderDeadlineProducts(room);
                    updateModalOkButton();
                }
                function closeModal() {
                    const overlay = $('#modal');
                    const modalEl = overlay.querySelector('.modal');
                    modalEl.classList.remove('show');
                    overlay.classList.remove('show');
                    setTimeout(() => overlay.style.display = 'none', 260);
                    currentDeadlineRoomNumber = null;
                    appData.selectedRoom = null;
                    deadlineModalState = null;
                    updateModalOkButton();
                }

                function toggleDeadlinesSelectMode() {
                    deadlinesSelectMode = !deadlinesSelectMode;
                    const btn = $('#deadlines-select-mode-btn');
                    const countEl = $('#deadlines-selected-count');
                    const printBtn = $('#deadlines-print-btn');
                    if (btn) {
                        if (deadlinesSelectMode) {
                            btn.classList.add('active');
                            btn.innerHTML = '<i class="fas fa-check-square"></i> Отменить выбор';
                        } else {
                            btn.classList.remove('active');
                            btn.innerHTML = '<i class="fas fa-check-square"></i> Выбрать номера';
                            deadlinesSelectedRooms.clear();
                            updateDeadlinesSelectedCount();
                            renderRooms();
                        }
                    }
                    if (countEl) countEl.style.display = deadlinesSelectMode ? 'inline' : 'none';
                    if (printBtn) printBtn.style.display = deadlinesSelectMode && deadlinesSelectedRooms.size > 0 ? 'inline-flex' : 'none';
                }

                function toggleDeadlineRoomSelection(roomNumber) {
                    const roomStr = String(roomNumber);
                    if (deadlinesSelectedRooms.has(roomStr)) {
                        deadlinesSelectedRooms.delete(roomStr);
                    } else {
                        deadlinesSelectedRooms.add(roomStr);
                    }
                    updateDeadlinesSelectedCount();
                    renderRooms();
                }

                function updateDeadlinesSelectedCount() {
                    const count = deadlinesSelectedRooms.size;
                    const countEl = $('#deadlines-selected-number');
                    const printBtn = $('#deadlines-print-btn');
                    if (countEl) countEl.textContent = String(count);
                    if (printBtn) printBtn.style.display = count > 0 ? 'inline-flex' : 'none';
                }

                function printDeadlinesSelected() {
    if (deadlinesSelectedRooms.size === 0) return;
    const now = new Date();
    const dateString = now.toLocaleDateString('ru-RU');
    const selectedRooms = Array.from(deadlinesSelectedRooms).map(Number).sort((a, b) => a - b);
    // 🔸 Исключаем номера, у которых статус "OK" (Сроки в порядке)
const filteredRooms = selectedRooms.filter(num => {
    const room = (appData.rooms || []).find(r => r && r.number === num);
    // Если записи о комнате нет — печатаем (пользователь мог просто выбрать номер)
    if (!room) return true;
    // room.deadlinesStatus хранит текущее состояние (NEUTRAL / PRODUCTS / OK)
    return room.deadlinesStatus !== DEADLINE_STATUS.OK;
});

    const roomsData = filteredRooms.map(num => {
        const room = appData.rooms.find(r => r && r.number === num);
        const products = room && room.products ? room.products : {};
        const productList = Object.entries(products)
            .filter(([, count]) => Number(count) > 0)
            .map(([key, count]) => {
                const name = appData.products[key] || key;
                return count > 1 ? `${name} x${count}` : name;
            })
            .join(', ');
        return { number: num, products: productList };
    });

    // 🔸 Собираем суммарное количество каждого продукта по всем выбранным номерам
    const totalProductCounts = {};
    selectedRooms.forEach(num => {
        const room = appData.rooms.find(r => r && r.number === num);
        if (!room || !room.products) return;
        Object.entries(room.products).forEach(([key, cnt]) => {
            const n = Number(cnt) || 0;
            if (n > 0) totalProductCounts[key] = (totalProductCounts[key] || 0) + n;
        });
    });
    const totalProductsEntries = Object.entries(totalProductCounts)
        .sort((a, b) => b[1] - a[1]);

    // 🔸 Добавляем в общий список (они просто продолжат идти после номеров)
    if (totalProductsEntries.length > 0) {
        roomsData.push({ number: '', products: '' }); // пустая строка
        roomsData.push({ number: '', products: 'Необходимые продукты' });
        totalProductsEntries.forEach(([key, cnt]) => {
            const name = appData.products[key] || key;
            roomsData.push({ number: '', products: `${name} x${cnt}` });
        });
    }

    const itemsPerPage = 72;
    const pageCount = Math.ceil(roomsData.length / itemsPerPage);
    const printWindow = window.open('', '_blank');
    let htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Expirations ${dateString}</title>
            <style>
                @page {
                    size: A4 landscape;
                    margin: 1cm;
                }
                body { 
                    font-family: Times New Roman, sans-serif; 
                    margin: 0;
                    padding: 0;
                }
                .page-container {
                    display: flex;
                    justify-content: space-around;
                    width: 100%;
                    height: 95vh;
                    page-break-after: always;
                }
                .page-column {
                    flex: 1;
                    padding-top: 1cm;
                    padding-left: 1cm;
                    padding-right: 1cm;
                    box-sizing: border-box;
                }
                .print-table { 
                    width: 100%; 
                    border-collapse: collapse;
                    font-size: 10px;
                }
                .print-table th, .print-table td { 
                    border: 1px solid #000; 
                    padding: 0px;
                    height: 16px;
                }
                .print-table th { 
                    background: #f0f0f0; 
                    font-weight: bold; 
                    text-align: center;
                }
                .print-table .number-col { 
                    width: 50px; 
                    text-align: center; 
                }
                .print-table .products-col { 
                    width: auto; 
                    text-align: center;
                }
                @media print {
                    body { 
                        margin: 0;
                        padding: 0;
                    }
                    .page-container {
                        height: 95vh;
                    }
                }
            </style>
        </head>
        <body>
    `;
    for (let pageNum = 0; pageNum < pageCount; pageNum++) {
        const pageStart = pageNum * itemsPerPage;
        const pageEnd = pageStart + itemsPerPage;
        const pageItems = roomsData.slice(pageStart, pageEnd);
        const leftPage = pageItems.slice(0, 36);
        const rightPage = pageItems.slice(36, 72);
        while (leftPage.length < 36) leftPage.push(null);
        while (rightPage.length < 36) rightPage.push(null);
        htmlContent += `
            <div class="page-container">
                <div class="page-column">
                    <table class="print-table">
                        <thead>
                            <tr>
                                <th class="number-col"><font size="2">№</font></th>
                                <th class="products-col"><font size="2">Expirations of ${dateString}</font></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        for (let i = 0; i < 36; i++) {
            if (leftPage[i]) {
                htmlContent += `
                    <tr>
                        <td class="number-col"><strong><font size="2">${leftPage[i].number}</font></strong></td>
                        <td class="products-col" style="text-align: left; padding-left: 5px"><font size="1">${leftPage[i].products || '&nbsp;'}</font></td>
                    </tr>
                `;
            } else {
                htmlContent += `
                    <tr>
                        <td class="number-col">&nbsp;</td>
                        <td class="products-col">&nbsp;</td>
                    </tr>
                `;
            }
        }
        htmlContent += `
                        </tbody>
                    </table>
                </div>
                <div class="page-column">
                    <table class="print-table">
                        <thead>
                            <tr>
                                <th class="number-col"><font size="2">№</font></th>
                                <th class="products-col"><font size="2">Expirations of ${dateString}</font></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        for (let i = 0; i < 36; i++) {
            if (rightPage[i]) {
                htmlContent += `
                    <tr>
                        <td class="number-col"><strong><font size="2">${rightPage[i].number}</font></strong></td>
                        <td class="products-col" style="text-align: left; padding-left: 5px"><font size="1">${rightPage[i].products || '&nbsp;'}</font></td>
                    </tr>
                `;
            } else {
                htmlContent += `
                    <tr>
                        <td class="number-col">&nbsp;</td>
                        <td class="products-col">&nbsp;</td>
                    </tr>
                `;
            }
        }
        htmlContent += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    htmlContent += `
        </body>
        </html>
    `;
    printWindow.document.write(htmlContent);
    printWindow.document.close();
    printWindow.onload = function() {
        setTimeout(() => {
            printWindow.print();
            setTimeout(() => {
                printWindow.close();
            }, 500);
        }, 500);
    };
}


                function computeDeadlinesSummary() {
                    const summary = {
                        ok: 0,
                        products: 0,
                        neutral: 0,
                        productTotals: {}
                    };
                    (appData.rooms || []).forEach(room => {
                        if (!room) return;
                        normalizeRoomDeadlineStatus(room);
                        const status = room.deadlinesStatus || DEADLINE_STATUS.NEUTRAL;
                        if (status === DEADLINE_STATUS.OK) summary.ok += 1;
                        else if (status === DEADLINE_STATUS.PRODUCTS) summary.products += 1;
                        else summary.neutral += 1;

                        const entries = Object.entries(room.products || {});
                        entries.forEach(([key, count]) => {
                            const num = Number(count);
                            if (!num) return;
                            summary.productTotals[key] = (summary.productTotals[key] || 0) + num;
                        });
                    });
                    return summary;
                }
                function renderDeadlinesStats() {
                    const data = computeDeadlinesSummary();
                    const okEl = $('#deadlines-count-ok');
                    const prodEl = $('#deadlines-count-products');
                    const neutralEl = $('#deadlines-count-neutral');
                    if (okEl) okEl.textContent = data.ok;
                    if (prodEl) prodEl.textContent = data.products;
                    if (neutralEl) neutralEl.textContent = data.neutral;

                    const productsContainer = $('#deadlines-products-stats');
                    if (!productsContainer) return;
                    productsContainer.innerHTML = '';
                    const entries = Object.entries(data.productTotals).sort((a, b) => b[1] - a[1]);
                    if (entries.length === 0) {
                        const empty = document.createElement('div');
                        empty.className = 'muted';
                        empty.style.fontSize = '12px';
                        empty.textContent = 'Нет выбранных продуктов';
                        productsContainer.appendChild(empty);
                        return;
                    }
                    entries.forEach(([key, count]) => {
                        const name = appData.products[key] || key;
                        const chip = document.createElement('div');
                        chip.style.padding = '6px 10px';
                        chip.style.borderRadius = '999px';
                        chip.style.background = 'rgba(15,23,36,0.06)';
                        chip.style.border = '1px solid rgba(15,23,36,0.08)';
                        chip.textContent = `${name}  x${count}`;
                        productsContainer.appendChild(chip);
                    });
                }
                function openDeadlinesStatsModal() {
                    const overlay = $('#deadlines-stats-modal');
                    if (!overlay) return;
                    deadlinesStatsModalOpen = true;
                    renderDeadlinesStats();
                    overlay.classList.add('show');
                    overlay.style.display = 'flex';
                    const modalEl = overlay.querySelector('.modal');
                    if (modalEl) modalEl.classList.add('show');
                }
                function closeDeadlinesStatsModal() {
                    const overlay = $('#deadlines-stats-modal');
                    if (!overlay) return;
                    deadlinesStatsModalOpen = false;
                    const modalEl = overlay.querySelector('.modal');
                    if (modalEl) modalEl.classList.remove('show');
                    overlay.classList.remove('show');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 260);
                }
                function updateDeadlinesStatsIfOpen() {
                    if (!deadlinesStatsModalOpen) return;
                    renderDeadlinesStats();
                }

                /* renderProductButtons for forms */
                function renderProductButtons(container, keys = [], targetObj = {}, onChange = null, options = {}) {
    if (!container) return;
    
    // ОЧИЩАЕМ контейнер
    container.innerHTML = '';
    
    keys.forEach(k => {
        const name = appData.products[k] || k;
        const emoji = (typeof PRODUCT_EMOJIS !== 'undefined' && PRODUCT_EMOJIS[k]) ? PRODUCT_EMOJIS[k] : '';
        const btn = document.createElement('button');
        btn.className = 'product-btn';
        btn.dataset.product = k;
        
        const textSpan = document.createElement('span');
        textSpan.className = 'btn-text';
        textSpan.textContent = emoji ? `${emoji} ${name}` : name;
        btn.appendChild(textSpan);
        
        const maxQ = MULTI_LIMITS[k] || 1;
        const cur = targetObj[k] || 0;
        
        const span = document.createElement('span');
        span.className = 'product-count';
        if (cur > 0) {
            btn.classList.add('active');
            span.textContent = cur;
        }
        btn.appendChild(span);
        
        btn.addEventListener('click', () => {
            const current = targetObj[k] || 0;
            const next = (current + 1) % (maxQ + 1);
            
            if (next === 0) {
                delete targetObj[k];
            } else {
                targetObj[k] = next;
            }
            
            // ОБНОВЛЯЕМ отображение кнопки
            const countSpan = btn.querySelector('.product-count');
            if (next > 0) {
                btn.classList.add('active');
                countSpan.textContent = next;
            } else {
                btn.classList.remove('active');
                countSpan.textContent = '';
            }
            
            // ВЫЗЫВАЕМ колбек для обновления состояния
            if (typeof onChange === 'function') onChange(k, next);
            saveDebounced();
        });
        
        container.appendChild(btn);
    });
}

                /* ===== GIH logic ===== */
                let gihTempProducts = {}; let editingGIHId = null; let gihSortAsc = true;

                /* sort */
                function sortGIHRecords() {
                    appData.gihRecords.sort((a, b) => {
                        const na = Number(a.room); const nb = Number(b.room);
                        if (!isFinite(na) && !isFinite(nb)) return 0;
                        if (!isFinite(na)) return 1;
                        if (!isFinite(nb)) return -1;
                        return gihSortAsc ? (na - nb) : (nb - na);
                    });
                }

                /* rerender all */
                function renderAllGIHRecords() {
                    const container = $('#gih-records');
                    container.innerHTML = '';
                    sortGIHRecords();
                    (appData.gihRecords || []).forEach(rec => renderGIHRecord(rec));
                }
                updateGIHSummary();

                /* build form area */




                function buildGIHProductsArea() {
                    // временный объект для хранения выбранных количеств при создании/редактировании записи
                    gihTempProducts = {};
                    const area = document.getElementById('gih-products-area');
                    if (!area) return;
                    area.innerHTML = '';

                    const columnsWrap = document.createElement('div');
                    columnsWrap.className = 'gih-products-columns';

                    const cols = [
                        { title: 'Дверца', items: ['twix', 'jager', 'gin', 'rum', 'cognac', 'whiskey', 'vodka'] },
                        { title: 'Напитки', items: ['pepper', 'redbull', 'cola', 'baikal', 'borjomi'] },
                        { title: 'Алкоголь', items: ['white_wine', 'red_wine', 'corona', 'stella', 'gancha', 'martini', 'loriot', 'whiskey02'] },
                        { title: 'Соки', items: ['apple', 'tomato', 'orange', 'cherry'] }
                    ];

                    cols.forEach(col => {
                        const colEl = document.createElement('div');
                        colEl.className = 'gih-column';
                        const titleEl = document.createElement('div');
                        titleEl.className = 'gih-column-title';
                        titleEl.textContent = col.title;
                        colEl.appendChild(titleEl);

                        const row = document.createElement('div');
                        row.className = 'gih-row';
                        // Используем существующую функцию renderProductButtons — она добавит кнопки с нужной логикой (счётчики, ограничения и клики)
                        renderProductButtons(row, col.items, gihTempProducts, () => { });
                        colEl.appendChild(row);
                        columnsWrap.appendChild(colEl);
                    });

                    area.appendChild(columnsWrap);
                }




                function clearGIHForm() { $('#gih-room').value = ''; gihTempProducts = {}; buildGIHProductsArea(); editingGIHId = null; }

                /* handle form save (create/edit) */
                function handleGIHSave() {
                    const roomInput = $('#gih-room').value.trim(); if (!roomInput) { $('#gih-room').focus(); return alert('Введите номер комнаты'); }

                    const area = $('#gih-products-area'); const selectedCounts = {};
                    area.querySelectorAll('.product-btn.active').forEach(btn => {
                        const key = btn.dataset.product;
                        if (!key) return;
                        const q = btn.querySelector('.product-count');
                        selectedCounts[key] = q ? parseInt(q.textContent || '1', 10) : 1;
                    });

                    if (Object.keys(selectedCounts).length === 0) {
                        for (const [k, v] of Object.entries(gihTempProducts)) if (v > 0) selectedCounts[k] = v;
                    }
                    if (Object.keys(selectedCounts).length === 0) return alert('Выберите хотя бы один продукт');

                    if (editingGIHId) {
                        const rec = appData.gihRecords.find(r => r.id === editingGIHId); if (!rec) return alert('Запись не найдена');
                        const queues = {};
                        (rec.products || []).forEach(p => { queues[p.name] = queues[p.name] || []; queues[p.name].push(Number(p.status || 0)); });
                        const newArr = [];
                        Object.entries(selectedCounts).forEach(([k, cnt]) => {
                            for (let i = 0; i < cnt; i++) {
                                const st = (queues[k] && queues[k].length) ? queues[k].shift() : 0;
                                newArr.push({ name: k, status: st });
                            }
                        });
                        rec.room = roomInput; rec.products = newArr; rec.updatedAt = new Date().toISOString();
                        // ensure consistent statusMode: if products non-neutral, clear mode
                        if ((rec.products || []).some(p => Number(p.status || 0) !== 0)) rec.statusMode = null;
                        sortGIHRecords(); renderAllGIHRecords(); saveDebounced();
                        updateGIHSummary();
                    } else {
                        const productsArr = [];
                        Object.entries(selectedCounts).forEach(([k, cnt]) => { for (let i = 0; i < cnt; i++) productsArr.push({ name: k, status: 0 }); });
                        const safeId = `${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
                        const rec = { id: safeId, room: roomInput, products: productsArr, statusMode: null, comment: '', createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), completedAt: null, savedAt: null };
                        appData.gihRecords.push(rec);
                        sortGIHRecords(); renderAllGIHRecords(); saveDebounced();
                    }

                    $('#gih-form').style.display = 'none'; clearGIHForm();
                }

                /* normalize old formats and ensure consistency */
                function normalizeRecordProducts(record) {
                    if (!record) return;
                    if (!Array.isArray(record.products)) {
                        const newArr = [];
                        const p = record.products || {};
                        Object.entries(p).forEach(([k, v]) => {
                            if (typeof v === 'number') { for (let i = 0; i < v; i++) newArr.push({ name: k, status: 0 }); }
                            else if (typeof v === 'string') { const map = { inplace: 2, added: 1, removed: 3 }; const st = map[v] || 0; newArr.push({ name: k, status: st }); }
                            else newArr.push({ name: k, status: 0 });
                        });
                        record.products = newArr;
                    }
                    if (record.status && typeof record.status === 'object' && !('statusMode' in record)) {
                        const s = record.status;
                        if (s.dnd) record.statusMode = 'dnd';
                        else if (s.allInPlace) record.statusMode = 'allInPlace';
                        else if (s.putOut) record.statusMode = 'putOut';
                        else record.statusMode = null;
                    }
                    if (!('statusMode' in record)) record.statusMode = null;
                    if (record.statusMode === '') record.statusMode = null;
                    // If any product non-neutral, clear mode to avoid conflict
                    const anyNon = (record.products || []).some(p => Number(p.status || 0) !== 0);
                    if (anyNon && record.statusMode) record.statusMode = null;
                }

                /* Save rules: enabled if either mode selected OR all products non-neutral */
                function canSaveCard(rec) {
                    if (!rec) return false;
                    const allNonNeutral = (rec.products || []).length > 0 && (rec.products || []).every(p => Number(p.status || 0) !== 0);
                    const hasMode = rec.statusMode != null && rec.statusMode !== '';
                    return hasMode || allNonNeutral;
                }

                /* Format HH:MM */
                function formatHHMM(d) { const hh = String(d.getHours()).padStart(2, '0'); const mm = String(d.getMinutes()).padStart(2, '0'); return `${hh}:${mm}`; }

                /* Render single record card */

                /* Render single record card (updated view when saved) */

                /* Render single record card (updated view when saved) */

                /* Render single record card (updated view when saved) */

                /* Render single record card (updated view when saved) */
                function renderGIHRecord(record) {
                    const container = $('#gih-records');
                    normalizeRecordProducts(record);

                    const card = document.createElement('div');
                    card.className = 'gih-card';
                    card.setAttribute('data-id', record.id);

                    // Header: room on left, actions on the right (delete / saved time)
                    let rightActionsHtml = '';
                    if (record.savedAt) {
                        rightActionsHtml = `<div style="display:flex;gap:8px;align-items:center">
                                                        <div class="muted" style="font-weight:600">${record.savedAt}</div>
                                                        <button class="btn ghost small delete-btn" title="Удалить"><i class="fas fa-trash"></i></button>
                                                    </div>`;
                    } else {
                        rightActionsHtml = `<div style="display:flex;gap:8px">
                                                        <button class="btn ghost small edit-btn" title="Редактировать"><i class="fas fa-edit"></i></button>
                                                        <button class="btn ghost small delete-btn" title="Удалить"><i class="fas fa-trash"></i></button>
                                                    </div>`;
                    }

                    const headerHtml = `<div style="display:flex;justify-content:space-between;align-items:center;">
                                                    <div style="font-weight:700;color:var(--primary-strong)">${record.room}</div>
                                                    ${rightActionsHtml}
                                                </div>`;

                    // If record is saved -> show simplified saved view
                    if (record.savedAt) {
                        const allNonNeutral = (record.products || []).length > 0 && (record.products || []).every(p => Number(p.status || 0) !== 0);
                        let contentHtml = '';

                        if (record.statusMode) {
                            const groups = {};
                            (record.products || []).forEach(p => groups[p.name] = (groups[p.name] || 0) + 1);
                            const parts = Object.entries(groups).map(([k, cnt]) => {
                                const name = appData.products[k] || k;
                                return cnt > 1 ? `${name} x${cnt}` : `${name}`;
                            });
                            const productsDisplay = `<div class="muted" style="margin-top:10px">${parts.join(', ') || '&nbsp;'}</div>`;
                            const modeLabelMap = { dnd: 'DND', allInPlace: 'Всё на месте', putOut: 'Всё выложили', emptied: 'Опустошён' };
                            const modeLabel = modeLabelMap[record.statusMode] || record.statusMode || '';
                            const modeHtml = modeLabel ? `<div style="margin-top:8px; font-weight:600">${modeLabel}</div>` : '';
                            const commentHtml = record.comment ? `<div class="muted" style="margin-top:8px"><strong>Комментарий:</strong> ${record.comment}</div>` : '';
                            contentHtml = productsDisplay + modeHtml + commentHtml;
                            card.innerHTML = headerHtml + contentHtml;
                            container.appendChild(card);

                            const delBtnSaved = card.querySelector('.delete-btn');
                            if (delBtnSaved) {
                                delBtnSaved.addEventListener('click', () => {
                                    if (confirm('Удалить запись?')) {
                                        appData.gihRecords = appData.gihRecords.filter(r => r.id !== record.id);
                                        card.remove();
                                        saveDebounced();
                                        renderAllGIHRecords();
                                    }
                                });
                            }
                            return;
                        } else if (allNonNeutral) {
                            const statusOrder = [1, 2, 3, 4];
                            const statusClass = { 1: 't-added', 2: 't-here', 3: 't-out', 4: 't-miss' };
                            const statusLabel = { 1: 'Пополнено', 2: 'На месте', 3: 'Выложили', 4: 'Не пополнено' };

                            const groups = {};
                            (record.products || []).forEach(p => {
                                const st = Number(p.status || 0);
                                const nm = p.name;
                                groups[st] = groups[st] || {};
                                groups[st][nm] = (groups[st][nm] || 0) + 1;
                            });

                            const lines = [];
                            statusOrder.forEach(st => {
                                if (!groups[st]) return;
                                const names = Object.entries(groups[st]).map(([k, cnt]) => {
                                    const name = appData.products[k] || k;
                                    return cnt > 1 ? `${name} x${cnt}` : `${name}`;
                                });
                                if (names.length) {
                                    const line = `<div style="margin-top:8px;">
                                                                    <div class="${statusClass[st]}" style="font-weight:700; font-size:13px">${statusLabel[st]}:</div>
                                                                    <div class="muted" style="margin-top:4px">${names.join(', ')}</div>
                                                                </div>`;
                                    lines.push(line);
                                }
                            });

                            const commentHtml = record.comment ? `<div class="muted" style="margin-top:8px"><strong>Комментарий:</strong> ${record.comment}</div>` : '';
                            contentHtml = lines.join('') + commentHtml;

                            card.innerHTML = headerHtml + contentHtml;
                            container.appendChild(card);

                            const delBtnSaved = card.querySelector('.delete-btn');
                            if (delBtnSaved) {
                                delBtnSaved.addEventListener('click', () => {
                                    if (confirm('Удалить запись?')) {
                                        appData.gihRecords = appData.gihRecords.filter(r => r.id !== record.id);
                                        card.remove();
                                        saveDebounced();
                                        renderAllGIHRecords();
                                    }
                                });
                            }
                            return;
                        } else {
                            const parts = (record.products || []).map(p => appData.products[p.name] || p.name);
                            const productsHtml = `<div class="muted" style="margin-top:10px">${parts.join(', ') || '&nbsp;'}</div>`;
                            const commentHtml = record.comment ? `<div class="muted" style="margin-top:8px"><strong>Комментарий:</strong> ${record.comment}</div>` : '';
                            card.innerHTML = headerHtml + productsHtml + commentHtml;
                            container.appendChild(card);
                            const delBtnSaved = card.querySelector('.delete-btn');
                            if (delBtnSaved) {
                                delBtnSaved.addEventListener('click', () => {
                                    if (confirm('Удалить запись?')) {
                                        appData.gihRecords = appData.gihRecords.filter(r => r.id !== record.id);
                                        card.remove();
                                        saveDebounced();
                                        renderAllGIHRecords();
                                    }
                                });
                            }
                            return;
                        }
                    }

                    // Normal (editable) view for not-yet-saved records
                    const productsHtml = `<div class="gih-products"></div>`;
                    const commentHtml = record.comment ? `<div class="muted" style="margin-top:8px"><strong>Комментарий:</strong> ${record.comment}</div>` : '';
                    const footerHtml = `<div class="gih-footer">
                                                    <button class="mode-btn" data-mode="dnd">DND</button>
                                                    <button class="mode-btn" data-mode="allInPlace">Всё на месте</button>
                                                    <button class="mode-btn" data-mode="putOut">Всё выложили</button>
  
<button class="mode-btn" data-mode="emptied">Опустошён</button>                                                  
                                                    <button class="btn ghost small" data-action="comment">Комментарий</button>
                                                </div>`;
                    const legendHtml = `<div class="legend">
                                                    <div class="item"><span class="color t-added"></span>Пополнено</div>
                                                    <div class="item"><span class="color t-here"></span>На месте</div>
                                                    <div class="item"><span class="color t-out"></span>Выложили</div>
                                                    <div class="item"><span class="color t-miss"></span>Не пополнено</div>
                                                </div>`;
                    const saveRowHtml = `<div class="card-footer-row">
                                                    <div style="flex:1"></div>
                                                    <div class="card-save-wrap">
                                                        <button class="card-save"${canSaveCard(record) ? '' : ' disabled'}>Сохранить</button>
                                                        <div class="saved-at">${record.savedAt ? `Сохранено в ${record.savedAt}` : ''}</div>
                                                    </div>
                                                </div>`;

                    card.innerHTML = headerHtml + productsHtml + commentHtml + footerHtml + legendHtml + saveRowHtml;

                    const prodWrap = card.querySelector('.gih-products'); prodWrap.innerHTML = '';
                    (record.products || []).forEach((entry, idx) => {
                        const key = entry.name;
                        const display = appData.products[key] || key;
                        const status = typeof entry.status === 'number' ? entry.status : 0;
                        const p = document.createElement('div');
                        p.className = 'gih-product status-' + status;
                        p.textContent = display;
                        p.dataset.index = idx;
                        p.dataset.key = key;
                        p.title = statusTitle(status);
                        p.addEventListener('click', () => {
                            const rec = appData.gihRecords.find(r => r.id === record.id);
                            if (!rec) return;
                            if (rec.statusMode) return;
                            const el = rec.products[parseInt(p.dataset.index, 10)];
                            el.status = (Number(el.status || 0) + 1) % 5;
                            p.className = 'gih-product status-' + el.status;
                            p.title = statusTitle(el.status);
                            saveDebounced();
                            updateCardSaveUI(rec, card);
                        });
                        prodWrap.appendChild(p);
                    });

                    container.appendChild(card);

                    card.querySelectorAll('.mode-btn').forEach(btn => {
                        const mode = btn.dataset.mode;
                        btn.classList.toggle('active', record.statusMode === mode);
                        btn.addEventListener('click', () => {
                            if (btn.disabled) return;
                            const rec = appData.gihRecords.find(r => r.id === record.id);
                            if (!rec) return;
                            rec.statusMode = (rec.statusMode === mode) ? null : mode;
                            saveDebounced();
                            updateCardSaveUI(rec, card);
                        });
                    });

                    const commentBtn = card.querySelector('[data-action="comment"]');
                    if (commentBtn) {
                        commentBtn.addEventListener('click', () => {
                            const val = prompt('Комментарий:', record.comment || '');
                            if (val !== null) { record.comment = val; saveDebounced(); card.remove(); renderGIHRecord(record); }
                        });
                    }

                    const editBtn = card.querySelector('.edit-btn');
                    if (editBtn) {
                        editBtn.addEventListener('click', () => {
                            editingGIHId = record.id;
                            $('#gih-form').style.display = 'block';
                            $('#gih-room').value = record.room;
                            setTimeout(() => { try { $('#gih-room').focus(); $('#gih-room').select(); } catch (e) { } }, 50);
                            gihTempProducts = {};
                            (record.products || []).forEach(p => { gihTempProducts[p.name] = (gihTempProducts[p.name] || 0) + 1; });
                            renderProductButtons($('#gih-products-area'), Object.keys(appData.products), gihTempProducts, () => { }, { allowMaxTwo: true });
                        });
                    }

                    const delBtn = card.querySelector('.delete-btn');
                    if (delBtn) {
                        delBtn.addEventListener('click', () => {
                            if (confirm('Удалить запись?')) {
                                appData.gihRecords = appData.gihRecords.filter(r => r.id !== record.id);
                                card.remove();
                                saveDebounced();
                                renderAllGIHRecords();
                            }
                        });
                    }

                    const saveBtn = card.querySelector('.card-save');
                    const savedAtEl = card.querySelector('.saved-at');

                    // В функции renderGIHRecord, в обработчике кнопки "Сохранить":
                    // В обработчике кнопки Сохранить в renderGIHRecord():
saveBtn.addEventListener('click', () => {
    const rec = appData.gihRecords.find(r => r.id === record.id);
    if (!rec) return;
    if (!canSaveCard(rec)) return;
    
    rec.savedAt = formatHHMM(new Date());
    rec.updatedAt = new Date().toISOString();
    savedAtEl.textContent = `Сохранено в ${rec.savedAt}`;

    const historyEntry = {
        id: rec.id,
        room: rec.room,
        products: JSON.parse(JSON.stringify(rec.products)),
        statusMode: rec.statusMode,
        comment: rec.comment,
        savedAt: rec.savedAt,
        createdAt: rec.createdAt || new Date().toISOString()
    };

    appData.gihHistory = appData.gihHistory || [];
    appData.gihHistory.unshift(historyEntry);
    
    // Резервное копирование истории
    backupHistory();
    
    saveDebounced();
    updateCardSaveUI(rec, card);
    card.remove();
    renderGIHRecord(rec);
    renderHistory();
});
                    updateGIHSummary();;

                    updateCardSaveUI(record, card);
                }
                function updateCardSaveUI(rec, cardEl) {
                    const record = rec;
                    const card = cardEl || document.querySelector(`.gih-card[data-id="${record.id}"]`);
                    if (!card) return;

                    // Determine any non-neutral product
                    const anyNonNeutral = (record.products || []).some(p => Number(p.status || 0) !== 0);
                    const allNonNeutral = (record.products || []).length > 0 && (record.products || []).every(p => Number(p.status || 0) !== 0);

                    // Mode buttons disabled if any product non-neutral
                    card.querySelectorAll('.mode-btn').forEach(b => {
                        b.disabled = anyNonNeutral;
                        // visual active class if selected
                        b.classList.toggle('active', record.statusMode === b.dataset.mode);
                    });

                    // If mode is set but anyNonNeutral is true -> clear mode to stay consistent
                    if (record.statusMode && anyNonNeutral) {
                        record.statusMode = null;
                        saveDebounced();
                        card.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    }

                    // Products disabled if a mode is active
                    card.querySelectorAll('.gih-product').forEach((pEl, idx) => {
                        if (record.statusMode) {
                            pEl.classList.add('disabled');
                            pEl.title = statusTitle(record.products[idx].status);
                        } else {
                            pEl.classList.remove('disabled');
                            pEl.title = statusTitle(record.products[idx].status);
                        }
                    });

                    // Save button enabled if mode selected OR all products non-neutral
                    const enabled = (record.statusMode !== null) || allNonNeutral;
                    const saveBtn = card.querySelector('.card-save');
                    if (saveBtn) saveBtn.disabled = !enabled;

                    // saved-at text
                    const savedAtEl = card.querySelector('.saved-at');
                    if (savedAtEl) savedAtEl.textContent = record.savedAt ? `Сохранено в ${record.savedAt}` : '';
                }

                /* ===== LOAD & NAV ===== */
                async function loadData() {
    try {
        // Сначала пытаемся загрузить из Firebase
        const snapshot = await database.ref('minibarData').once('value');
        const firebaseData = snapshot.val();
        
        if (firebaseData) {
            // Данные из Firebase есть - используем их
            console.log('Загружаем данные из Firebase');
            isUpdatingFromFirebase = true;
            Object.assign(appData, firebaseData);
            localStorage.setItem('hotelMinibarData', JSON.stringify(appData));
            isUpdatingFromFirebase = false;
        } else {
            // Firebase пуст - пробуем локальные данные
            console.log('Firebase пуст, загружаем из localStorage');
            const raw = localStorage.getItem('hotelMinibarData');
            if (raw) {
                try {
                    const parsed = JSON.parse(raw);
                    Object.assign(appData, parsed);
                } catch (e) {
                    console.warn('Ошибка парсинга localStorage:', e);
                }
            }
        }
    } catch (error) {
        // Ошибка Firebase - используем локальные данные
        console.error('Ошибка загрузки из Firebase, используем localStorage:', error);
        const raw = localStorage.getItem('hotelMinibarData');
        if (raw) {
            try {
                const parsed = JSON.parse(raw);
                Object.assign(appData, parsed);
            } catch (e) {
                console.warn(e);
            }
        }
    }
    
    // Инициализируем массивы если они undefined
    appData.gihRecords = appData.gihRecords || [];
    appData.gihHistory = appData.gihHistory || [];
    appData.accises = appData.accises || [];
    appData.rooms = appData.rooms || [];
    
    // Обновляем UI
    renderHistory();
    appData.gihRecords.forEach(r => normalizeRecordProducts(r));
    (appData.accises || []).forEach(renderAcciseItem);
    updateAcciseStats();
    renderRooms();
    renderAllGIHRecords();
    buildGIHProductsArea();
    
    // Обновляем сводки
    updateGIHSummary();
    updateGIHRoomsSummary();
}

                function initNav() {
    // desktop nav items
    $$('.nav-item').forEach(item => {
        item.addEventListener('click', () => {
            $$('.nav-item').forEach(n => n.classList.remove('active')); 
            item.classList.add('active');
            const tab = item.dataset.tab;
            showTab(tab);
            syncBottomNav(tab);
        });
    });

    // bottom nav items (MOBILE)
    $$('#bottomNav .b-item').forEach(item => {
        item.addEventListener('click', () => {
            $$('#bottomNav .b-item').forEach(n => n.classList.remove('active')); 
            item.classList.add('active');
            const tab = item.dataset.tab;
            showTab(tab);
            syncTopNav(tab);
        });
    });
}
                function syncBottomNav(tab) {
                    const bottom = $$('#bottomNav .b-item');
                    bottom.forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
                }
                // === ЕДИНАЯ ФУНКЦИЯ showTab ДЛЯ ВСЕХ ВКЛАДОК ===
                function showTab(tab) {
                    // Скрываем все секции динамически
                    const allEls = document.querySelectorAll('[id$="-section"]');
                    allEls.forEach(el => {
                        el.classList.add('hidden');
                        el.classList.remove('show');
                        el.style.display = 'none';
                    });

                    // Показываем выбранную секцию
                    const targetSection = document.getElementById(tab + '-section');
                    if (targetSection) {
                        targetSection.classList.remove('hidden');
                        targetSection.classList.add('show');
                        targetSection.style.display = 'block';
                    }

                    // Синхронизируем навигацию
                    syncBottomNav(tab);
                    syncTopNav(tab);

                    // Прокрутка к началу контента
                    try {
                        const mainContent = document.getElementById('main-content');
                        if (mainContent) {
                            mainContent.scrollIntoView({ behavior: 'smooth' });
                        }
                    } catch (e) { }
                }

                // === ОБНОВЛЕННАЯ ФУНКЦИЯ ДЛЯ СИНХРОНИЗАЦИИ ВЕРХНЕЙ НАВИГАЦИИ ===
                function syncTopNav(tab) {
                    const top = $$('.nav-item');
                    top.forEach(b => b.classList.toggle('active', b.dataset.tab === tab));

                    // Также активируем элементы бургер-меню
                    const burgerItems = $$('.mb-burger-item');
                    burgerItems.forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
                }

                /* MOBILE: hide bottom nav on scroll down, show on scroll up */
                (function bottomNavAutoHide() {
                    const nav = $('#bottomNav');
                    if (!nav) return;
                    let lastScroll = window.scrollY || document.documentElement.scrollTop;
                    let ticking = false;
                    window.addEventListener('scroll', () => {
                        if (window.innerWidth > 920) return; // only mobile
                        const cur = window.scrollY || document.documentElement.scrollTop;
                        if (!ticking) {
                            window.requestAnimationFrame(() => {
                                if (cur > lastScroll + 1) { nav.classList.add('hide'); } // scrolling down
                                else if (cur < lastScroll - 1) { nav.classList.remove('hide'); } // scrolling up
                                lastScroll = cur;
                                ticking = false;
                            });
                            ticking = true;
                        }
                    }, { passive: true });
                })();

                /* INIT */
                document.addEventListener('DOMContentLoaded', async () => {
    initNav();
    initAccises();
    initSroki();
    initGIH();
    initHistoryDateControls();
    
    // Восстанавливаем историю если нужно
    restoreHistoryIfNeeded();
    
    setupFirebaseListener();
    setupRoomsRealtimeListener();
    await loadData();
    
    // Дополнительная проверка истории
    if (!appData.gihHistory || appData.gihHistory.length === 0) {
        restoreHistoryIfNeeded();
    }
    
    cleanupOldGIHRecords();
    scheduleGIHDailyCleanup();

    const activeTop = document.querySelector('.nav-item.active')?.dataset?.tab || 'accises';
    syncBottomNav(activeTop);
    
    // Инициализируем правильное отображение активной вкладки
    showTab(activeTop);
    
    // Инициализируем калькулятор после правильного отображения вкладок
    initCalculator();

    window.addEventListener('orientationchange', () => { 
        if ($('#modal').classList.contains('show')) closeModal(); 
    });
});

                /* initGIH (form controls) */
                function initGIH() {
                    buildGIHProductsArea();
                    $('#add-gih-btn').addEventListener('click', () => {
                        const f = $('#gih-form');
                        if (f.style.display === 'block') { f.style.display = 'none'; editingGIHId = null; clearGIHForm(); }
                        else { f.style.display = 'block'; editingGIHId = null; clearGIHForm(); setTimeout(() => { try { $('#gih-room').focus(); $('#gih-room').select(); } catch (e) { } }, 40); }
                    });
                    $('#cancel-gih').addEventListener('click', () => { $('#gih-form').style.display = 'none'; editingGIHId = null; clearGIHForm(); });
                    $('#save-gih').addEventListener('click', handleGIHSave);
                    // Sort toggle button
                    try {
                        const sortBtn = $('#gih-sort-btn');
                        if (sortBtn) {
                            sortBtn.addEventListener('click', () => {
                                gihSortAsc = !gihSortAsc;
                                // update icon
                                sortBtn.innerHTML = gihSortAsc ? '<i class="fas fa-sort-numeric-down"></i>'
                                    : '<i class="fas fa-sort-numeric-up"></i>';
                                // persist choice
                                try {
                                    localStorage.setItem('gihSortDirection', gihSortAsc ? 'asc' : 'desc');
                                    localStorage.setItem('gihSortAsc', JSON.stringify(gihSortAsc));
                                } catch (e) { }
                                renderAllGIHRecords();
                            });
                        }
                    } catch (e) { }

                }

                /* Escape closes modal */
                window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if ($('#modal').classList.contains('show')) closeModal();
        else if ($('#deadlines-stats-modal').classList.contains('show')) closeDeadlinesStatsModal();
    }
});

                /* ==== Calculator: product chips with totals ==== */
                function initCalculator() {
                    const chipsWrap = document.getElementById('calc-chips');
                    const totalEl = document.getElementById('calc-total');
                    const selectedEl = document.getElementById('calc-selected');
                    const resetSelectBtn = document.getElementById('calc-reset');
                    if (!chipsWrap || !totalEl || !selectedEl || !resetSelectBtn) return;


                    const prices = {
                        twix: 250,
                        jager: 750,
                        gin: 850,
                        rum: 750,
                        cognac: 1900,
                        whiskey: 1300,
                        vodka: 590,
                        pepper: 350,
                        redbull: 490,
                        cola: 350,
                        baikal: 290,
                        borjomi: 290,
                        white_wine: 1250,
                        red_wine: 1250,
                        apple: 450,
                        tomato: 450,
                        corona: 720,
                        stella: 650,
                        gancha: 1550,
                        martini: 1550,
                        orange: 450,
                        cherry: 450,
                        loriot: 9800,
                        whiskey02: 3900
                    };

                    const categories = [
                        { title: 'Дверца', items: ['twix', 'jager', 'gin', 'rum', 'cognac', 'whiskey', 'vodka'] },
                        { title: 'Напитки', items: ['pepper', 'redbull', 'cola', 'baikal', 'borjomi'] },
                        { title: 'Алкоголь', items: ['white_wine', 'red_wine', 'corona', 'stella', 'gancha', 'martini', 'loriot', 'whiskey02'] },
                        { title: 'Соки', items: ['apple', 'tomato', 'orange', 'cherry'] }
                    ];
                    const order = categories.map(c => c.items).flat();

                    const counts = {};
                    order.forEach(k => counts[k] = 0);

                    function formatMoney(n) { return new Intl.NumberFormat('ru-RU').format(n) + ' ₽'; }

                    function recalc() {
    let sum = 0;
    const lines = [];
    order.forEach(k => {
        const c = counts[k] || 0;
        if (c > 0) {
            sum += c * (prices[k] || 0);
            const name = appData.products[k] || k;
            lines.push(`${name} - ${c} шт.`);
        }
    });

    // Обновляем итоговую сумму
    totalEl.textContent = formatMoney(sum);

    // Показываем список выбранных товаров только если есть элементы
    // selectedEl — это сам блок с id="calc-selected"
    // его parentElement в текущей структуре — контейнер, который содержит заголовок "Выбрано" и сам selectedEl.
    if (lines.length > 0) {
        selectedEl.innerHTML = lines.map(t => `<div>${t}</div>`).join('');
        if (selectedEl.parentElement) selectedEl.parentElement.style.display = 'block';
    } else {
        // очистим содержимое и скрываем весь блок с заголовком + списком
        selectedEl.innerHTML = '';
        if (selectedEl.parentElement) selectedEl.parentElement.style.display = 'none';
    }

    // обновляем состояние кнопок "-" (отключаем, если счётчик 0) и текст счетчиков на чипах
    chipsWrap.querySelectorAll('.calc-chip').forEach(ch => {
        const key = ch.getAttribute('data-key');
        const minus = ch.querySelector('[data-act="minus"]');
        const counter = ch.querySelector('.calc-count');
        if (minus) minus.classList.toggle('disabled', counts[key] <= 0);
        if (counter) counter.textContent = String(counts[key] || 0);
    });
}


                    function makeChip(key) {
                        const name = appData.products[key] || key;
                        const emoji = (typeof PRODUCT_EMOJIS !== 'undefined' && PRODUCT_EMOJIS[key]) ? PRODUCT_EMOJIS[key] : '';
                        const price = prices[key] || 0;
                        const chip = document.createElement('div');
                        chip.className = 'calc-chip';
                        chip.setAttribute('data-key', key);

                        const minus = document.createElement('span');
                        minus.className = 'calc-op';
                        minus.textContent = '−';
                        minus.setAttribute('data-act', 'minus');

                        const label = document.createElement('div');
                        label.className = 'calc-label';
                        label.innerHTML = `${emoji ? `<span>${emoji}</span>` : ''}<span>${name}</span> <span class=\"calc-price\">${price} ₽</span>`;

                        const count = document.createElement('div');
                        count.className = 'calc-count';
                        count.textContent = '0';

                        const plus = document.createElement('span');
                        plus.className = 'calc-op';
                        plus.textContent = '+';
                        plus.setAttribute('data-act', 'plus');

                        minus.addEventListener('click', () => { if (counts[key] > 0) { counts[key]--; recalc(); } });
                        plus.addEventListener('click', () => { counts[key]++; recalc(); });

                        chip.appendChild(minus);
                        chip.appendChild(label);
                        chip.appendChild(count);
                        chip.appendChild(plus);
                        return chip;
                    }

                    chipsWrap.innerHTML = '';
                    const columnsWrap = document.createElement('div');
                    columnsWrap.className = 'gih-products-columns';
                    categories.forEach(cat => {
                        const colEl = document.createElement('div');
                        colEl.className = 'gih-column';
                        const titleEl = document.createElement('div');
                        titleEl.className = 'gih-column-title';
                        titleEl.textContent = cat.title;
                        colEl.appendChild(titleEl);
                        const row = document.createElement('div');
                        row.className = 'gih-row';
                        cat.items.forEach(k => row.appendChild(makeChip(k)));
                        colEl.appendChild(row);
                        columnsWrap.appendChild(colEl);
                    });
                    chipsWrap.appendChild(columnsWrap);

                    resetSelectBtn.addEventListener('click', () => {
                        order.forEach(k => counts[k] = 0);
                        recalc();
                    });

                    recalc();
                }

                /* small accessibility improvement: make bottom nav items keyboard focusable */
                (function makeBottomNavFocusable() {
                    try {
                        $$('#bottomNav .b-item').forEach(el => { el.setAttribute('tabindex', '0'); el.addEventListener('keydown', ev => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); el.click(); } }); });
                    } catch (e) { }
                })();

                // ==== BURGER MENU + MOBILE INDICATOR ====
                (function () {
                    const $ = (s, r = document) => r.querySelector(s);
                    const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));

                    // Burger interactions
                    const burgerBtn = $('#mbBurgerBtn');
                    const burgerMenu = $('#mbBurgerMenu');
                    if (burgerBtn && burgerMenu) {
                        burgerBtn.addEventListener('click', () => burgerMenu.classList.toggle('show'));
                        document.addEventListener('click', (e) => {
                            if (!burgerMenu.contains(e.target) && !burgerBtn.contains(e.target)) burgerMenu.classList.remove('show');
                        });
                        $$('.mb-burger-item').forEach(it => {
                            it.addEventListener('click', () => {
                                const tab = it.dataset.tab;
                                burgerMenu.classList.remove('show');
                                showTab(tab);
                            });
                        });
                    }

                    // Move mobile connection indicator (#mobileConnectionIndicator) into header on mobile; return on desktop
                    const mobInd = document.getElementById('mobileConnectionIndicator');
                    const headerRight = document.getElementById('mbHeaderRight');
                    const bottomNav = document.getElementById('bottomNav');
                    let placeholder = null;

                    function moveIndicatorIfNeeded() {
                        if (!mobInd || !headerRight) return;
                        if (window.innerWidth <= 920) {
                            if (!placeholder) {
                                placeholder = document.createElement('span');
                                placeholder.id = 'mobileIndicatorPlaceholder';
                                if (mobInd.parentNode) mobInd.parentNode.insertBefore(placeholder, mobInd);
                            }
                            headerRight.appendChild(mobInd); // move into header (right side)
                        } else {
                            if (placeholder && placeholder.parentNode) {
                                placeholder.parentNode.insertBefore(mobInd, placeholder);
                            } else if (bottomNav) {
                                bottomNav.insertBefore(mobInd, bottomNav.firstChild);
                            }
                        }
                    }
                    window.addEventListener('resize', moveIndicatorIfNeeded);
                    document.addEventListener('DOMContentLoaded', moveIndicatorIfNeeded);
                    // also call immediately in case this runs late
                    try { moveIndicatorIfNeeded(); } catch (e) { }
                })();


                /* ====== GIH SUMMARY ====== */
                function updateGIHSummary() {
                    const container = document.getElementById("gih-summary");
                    const listEl = document.getElementById("gih-summary-list");
                    if (!container || !listEl) return;

                    // Считаем все продукты
                    const counts = {};
                    (appData.gihRecords || []).forEach(rec => {
                        (rec.products || []).forEach(p => {
                            if (!p || !p.name) return;
                            counts[p.name] = (counts[p.name] || 0) + 1;
                        });
                    });

                    // Если нет данных, скрываем блок
                    const entries = Object.entries(counts);
                    if (entries.length === 0) {
                        container.style.display = "none";
                        listEl.innerHTML = "";
                        return;
                    }

                    // Сортируем по убыванию
                    entries.sort((a, b) => b[1] - a[1]);

                    // Формируем HTML-список
                    const htmlParts = entries.map(([key, count]) => {
                        const name = appData.products[key] || key;
                        return `<div><strong>${name}</strong>  x${count}</div>`;
                    });

                    listEl.innerHTML = htmlParts.join("");
                    container.style.display = "block";
                }


                /* ====== GIH ROOMS SUMMARY (numbers) ====== */
                function updateGIHRoomsSummary() {
                    const cont = document.getElementById('gih-rooms-summary');
                    const list = document.getElementById('gih-rooms-summary-list');
                    const savedEl = document.getElementById('rooms-saved-count');
                    const totalEl = document.getElementById('rooms-total-count');
                    if (!cont || !list) return;

                    const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
                    const total = records.length;
                    const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

                    // counters
                    if (savedEl) savedEl.textContent = String(saved);
                    if (totalEl) totalEl.textContent = String(total);

                    // empty state hides the block (consistently with products summary)
                    if (total === 0) {
                        cont.style.display = 'none';
                        list.innerHTML = '';
                        return;
                    } else {
                        cont.style.display = 'block';
                    }

                    // chips
                    let html = '';
                    records.forEach((rec, i) => {
                        const isSaved = !!rec.savedAt;
                        const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
                        const savedClass = isSaved ? ' saved' : '';
                        html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
                    });
                    list.innerHTML = html;

                    // scroll + flash
                    list.querySelectorAll('.room-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const id = chip.getAttribute('data-id');
                            const card = document.querySelector('.gih-card[data-id="' + id + '"]');
                            if (!card) return;
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.classList.remove('highlighted');
                            void card.offsetWidth; // reflow to restart animation
                            card.classList.add('highlighted');
                            setTimeout(() => card.classList.remove('highlighted'), 800);
                        });
                    });
                }

                // toggle (collapsed/expanded) like products list
                (function initGIHRoomsToggle() {
                    const box = document.getElementById('gih-rooms-summary');
                    const arrow = document.getElementById('gih-rooms-summary-arrow');
                    const list = document.getElementById('gih-rooms-summary-list');
                    if (!box || !arrow || !list) return;

                    let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
                    isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
                    function apply() {
                        box.classList.toggle('collapsed', isCollapsed === 'true');
                        box.classList.toggle('expanded', isCollapsed === 'false');
                        // compute max-height on expand to animate smoothly
                        if (isCollapsed === 'false') {
                            list.style.maxHeight = list.scrollHeight + 'px';
                            list.style.opacity = '1';
                        } else {
                            list.style.maxHeight = '0';
                            list.style.opacity = '0';
                        }
                    }
                    box.addEventListener('click', () => {
                        isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
                        localStorage.setItem('gihRoomsCollapsed', isCollapsed);
                        apply();
                    });
                    apply();
                })();
// Резервное копирование истории при каждом изменении
function backupHistory() {
    if (appData.gihHistory && appData.gihHistory.length > 0) {
        localStorage.setItem('gihHistory_backup', JSON.stringify(appData.gihHistory));
        localStorage.setItem('gihHistory_backup_timestamp', new Date().toISOString());
    }
}

// Восстановление истории если основная потерялась
function restoreHistoryIfNeeded() {
    if ((!appData.gihHistory || appData.gihHistory.length === 0) && localStorage.getItem('gihHistory_backup')) {
        console.log('Восстанавливаем историю из резервной копии');
        try {
            const backup = JSON.parse(localStorage.getItem('gihHistory_backup'));
            if (backup && backup.length > 0) {
                appData.gihHistory = backup;
                console.log('История восстановлена из резервной копии');
            }
        } catch (e) {
            console.error('Ошибка восстановления истории:', e);
        }
    }
}
            </script>
<script>
                function renderHistory() {
                    const historyList = document.getElementById('history-list');
                    if (!historyList) return;

                    historyList.innerHTML = '';

                    if (appData.gihHistory.length === 0) {
                        historyList.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">История пуста</div>';
                        return;
                    }

                    // Сортируем по дате (новые сверху)
                    const sortedHistory = [...appData.gihHistory].sort((a, b) =>
                        new Date(b.createdAt) - new Date(a.createdAt)
                    );

                    // Группируем по дате
                    const grouped = {};
                    sortedHistory.forEach(entry => {
                        const date = new Date(entry.createdAt).toLocaleDateString('ru-RU');
                        if (!grouped[date]) grouped[date] = [];
                        grouped[date].push(entry);
                    });

                    // Отрисовываем
                    Object.keys(grouped).forEach(date => {
                        const dateHeader = document.createElement('div');
                        dateHeader.style = 'font-weight:bold; margin-top:20px; margin-bottom:10px; padding-left:10px; border-left:3px solid var(--primary);';
                        dateHeader.textContent = date;
                        historyList.appendChild(dateHeader);

                        grouped[date].forEach(entry => {
                            const card = document.createElement('div');
                            card.className = 'gih-card';
                            card.style.marginBottom = '10px';

                            // Заголовок с номером комнаты и временем
                            const headerHtml = `
                                                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                                                        <div style="font-weight:700;color:var(--primary-strong)">${entry.room}</div>
                                                        <div class="muted" style="font-weight:700">${entry.savedAt}</div>
                                                    </div>
                                                `;

                            let contentHtml = '';

                            if (entry.statusMode) {
                                // Режим выбран (DND, Всё на месте, Всё выложили, Опустошён)
                                const modeLabels = {
                                    dnd: 'DND',
                                    allInPlace: 'Всё на месте',
                                    putOut: 'Всё выложили',
                                    emptied: 'Опустошён'
                                };

                                // Группируем продукты по имени и считаем количество
                                const productGroups = {};
                                entry.products.forEach(p => {
                                    const name = appData.products[p.name] || p.name;
                                    productGroups[name] = (productGroups[name] || 0) + 1;
                                });

                                // Форматируем продукты: "Название xКоличество"
                                const productList = Object.entries(productGroups)
                                    .map(([name, count]) => count > 1 ? `${name} x${count}` : name)
                                    .join(', ');

                                contentHtml = `
                                                        <div class="muted" style="margin-bottom:8px;">${productList}</div>
                                                        <div style="font-weight:600;margin-bottom:8px;">${modeLabels[entry.statusMode]}</div>
                                                    `;
                            } else {
                                // Без режима - группируем по статусам
                                const byStatus = {};
                                entry.products.forEach(p => {
                                    const status = p.status;
                                    if (!byStatus[status]) byStatus[status] = {};
                                    const name = appData.products[p.name] || p.name;
                                    byStatus[status][name] = (byStatus[status][name] || 0) + 1;
                                });

                                // Статусы в порядке отображения
                                const statusOrder = [1, 2, 3, 4];
                                const statusLabels = {
                                    1: 'Пополнено',
                                    2: 'На месте',
                                    3: 'Выложили',
                                    4: 'Не пополнено'
                                };
                                const statusClasses = {
                                    1: 't-added',
                                    2: 't-here',
                                    3: 't-out',
                                    4: 't-miss'
                                };

                                statusOrder.forEach(status => {
                                    if (byStatus[status]) {
                                        const products = Object.entries(byStatus[status])
                                            .map(([name, count]) => count > 1 ? `${name} x${count}` : name)
                                            .join(', ');

                                        if (products) {
                                            contentHtml += `
                                                                    <div style="margin-bottom:4px;">
                                                                        <div style="margin-bottom:4px;">
                                                                        <div class="${statusClasses[status]}" style="font-weight:700;font-size:13px">${statusLabels[status]}</div>
                                                                        <div class="muted" style="margin-top:4px">${products}</div>
                                                                    </div>
                                                                    </div>
                                                                `;
                                        }
                                    }
                                });
                            }

                            // Добавляем комментарий если есть
                            if (entry.comment) {
                                contentHtml += `
                                                        <div style="margin-top:8px;">
                                                        <div style="font-weight:700;font-size:13px">Комментарий</div>
                                                        <div class="muted" style="margin-top:4px">${entry.comment}</div>
                                                    </div>
                                                    `;
                            }

                            card.innerHTML = headerHtml + contentHtml;
                            historyList.appendChild(card);
                        });
                    });
                }
                // Переменные для управления датой в истории
                let historyCurrentDate = new Date();
                let historyDatePicker = null;

                // Инициализация управления датой в истории
                function initHistoryDateControls() {
    const prevBtn = document.getElementById('history-prev-day');
    const nextBtn = document.getElementById('history-next-day');
    const dateDisplay = document.getElementById('history-current-date');
    
    if (!prevBtn || !nextBtn || !dateDisplay) return;

    // Функция для обновления отображения даты
    function updateDateDisplay() {
        const dateDisplay = document.getElementById('history-current-date');
        if (!dateDisplay) return;

        // Форматируем дату для отображения
        const options = { day: 'numeric', month: 'long', year: 'numeric' };
        let dateText = historyCurrentDate.toLocaleDateString('ru-RU', options);
        dateText = dateText.replace(/\./g, ' ');

        dateDisplay.textContent = dateText;
        dateDisplay.title = historyCurrentDate.toLocaleDateString('ru-RU', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        // Отключаем кнопку "вперед", если достигнут сегодняшний день
        const today = new Date();
        const isToday = historyCurrentDate.toDateString() === today.toDateString();
        document.getElementById('history-next-day').disabled = isToday;
    }

    // Обработчик для перехода на предыдущий день
    prevBtn.addEventListener('click', () => {
        const newDate = new Date(historyCurrentDate);
        newDate.setDate(newDate.getDate() - 1);
        historyCurrentDate = newDate;
        updateDateDisplay();
        renderHistory();
    });

    // Обработчик для перехода на следующий день
    nextBtn.addEventListener('click', () => {
        const newDate = new Date(historyCurrentDate);
        newDate.setDate(newDate.getDate() + 1);
        
        // Не позволяем перейти дальше сегодняшнего дня
        const today = new Date();
        if (newDate <= today) {
            historyCurrentDate = newDate;
            updateDateDisplay();
            renderHistory();
        }
    });

    // Инициализация начальной даты
    updateDateDisplay();
}

                // Модифицируем функцию renderHistory для фильтрации по выбранной дате

                function renderHistory() {
                    const historyList = document.getElementById('history-list');
                    if (!historyList) return;

                    historyList.innerHTML = '';

                    // Фильтруем записи по выбранной дате
                    const selectedDateStr = historyCurrentDate.toLocaleDateString('ru-RU');
                    const filteredHistory = (appData.gihHistory || []).filter(entry => {
                        const entryDate = new Date(entry.createdAt).toLocaleDateString('ru-RU');
                        return entryDate === selectedDateStr;
                    });

                    if (filteredHistory.length === 0) {
                        historyList.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">За выбранный день записей нет</div>';
                        return;
                    }

                    // Сортируем по номеру комнаты (если есть цифры) — численно, иначе по строке
                    function roomToNum(e) {
                        if (!e) return Number.POSITIVE_INFINITY;
                        const r = (e.room || e.number || '');
                        if (typeof r === 'number') return r;
                        const m = String(r).match(/-?\d+/);
                        if (m) return parseInt(m[0], 10);
                        return Number.POSITIVE_INFINITY;
                    }
                    filteredHistory.sort((a, b) => {
                        const na = roomToNum(a);
                        const nb = roomToNum(b);
                        if (isFinite(na) && isFinite(nb)) return na - nb;
                        if (isFinite(na)) return -1;
                        if (isFinite(nb)) return 1;
                        // fallback to locale string compare (natural sort)
                        return String((a.room || a.number || '')).localeCompare(String((b.room || b.number || '')), 'ru-RU', { numeric: true });
                    });

                    // Отрисовываем записи за выбранную дату
                    filteredHistory.forEach(entry => {
                        const card = document.createElement('div');
                        card.className = 'gih-card';
                        card.style.marginBottom = '10px';

                        // Заголовок с номером комнаты и временем
                        const headerHtml = `
                                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                                                    <div style="font-weight:700;color:var(--primary-strong)">${entry.room}</div>
                                                    <div class="muted" style="font-weight:700">${entry.savedAt}</div>
                                                </div>
                                            `;

                        let contentHtml = '';

                        if (entry.statusMode) {
                            // Режим выбран (DND, Всё на месте, Всё выложили)
                            const modeLabels = {
                                dnd: 'DND',
                                allInPlace: 'Всё на месте',
                                putOut: 'Всё выложили',
                                emptied: 'Опустошён'
                            };

                            // Группируем продукты по имени и считаем количество
                            const productGroups = {};
                            (entry.products || []).forEach(p => {
                                const name = appData.products[p.name] || p.name;
                                productGroups[name] = (productGroups[name] || 0) + 1;
                            });

                            // Форматируем продукты: "Название xКоличество"
                            const productList = Object.entries(productGroups)
                                .map(([name, count]) => count > 1 ? `${name} x${count}` : name)
                                .join(', ');

                            contentHtml += `
                                                    <div style="margin-bottom:6px;">
                                                        <div class="muted">${productList}</div>
                                                        <div style="font-weight:600;margin-top:8px;">${modeLabels[entry.statusMode] || entry.statusMode}</div>
                                                    </div>
                                                `;
                        } else {
                            // Если нет режима — группируем по статусам
                            const byStatus = {};
                            (entry.products || []).forEach(p => {
                                const st = Number(p.status || 0);
                                const name = appData.products[p.name] || p.name;
                                byStatus[st] = byStatus[st] || {};
                                byStatus[st][name] = (byStatus[st][name] || 0) + 1;
                            });

                            // Статусы в порядке отображения
                            const statusOrder = [1, 2, 3, 4];
                            const statusLabels = {
                                1: 'Пополнено',
                                2: 'На месте',
                                3: 'Выложили',
                                4: 'Не пополнено'
                            };
                            const statusClasses = {
                                1: 't-added',
                                2: 't-here',
                                3: 't-out',
                                4: 't-miss'
                            };

                            statusOrder.forEach(status => {
                                if (byStatus[status]) {
                                    const products = Object.entries(byStatus[status])
                                        .map(([name, count]) => count > 1 ? `${name} x${count}` : name)
                                        .join(', ');

                                    if (products) {
                                        contentHtml += `
                                                                <div style="margin-bottom:8px;">
                                                                    <div style="margin-bottom:4px;">
                                                                        <div class="${statusClasses[status]}" style="font-weight:700;font-size:13px">${statusLabels[status]}:</div>
                                                                        <div class="muted" style="margin-top:4px">${products}</div>
                                                                    </div>
                                                                </div>
                                                            `;
                                    }
                                }
                            });
                        }

                        // Добавляем комментарий если есть
                        if (entry.comment) {
                            contentHtml += `
                                                    <div style="margin-top:8px;">
                                                        <div class="muted" style="font-weight:700;font-size:13px">Комментарий: <span class="muted" style="font-weight:400">${entry.comment}</span></div>
                                                    </div>
                                                `;
                        }

                        card.innerHTML = headerHtml + contentHtml;
                        historyList.appendChild(card);
                    });
                }

            </script>
<script>
                // === Обновление заголовка активной страницы в мобильной шапке ===
                (function () {
                    const pageTitle = document.getElementById('pageTitle');
                    if (!pageTitle) return;

                    const tabTitles = {
                        excises: 'Акцизы',
                        deadlines: 'Сроки',
                        gih: 'GIH',
                        emptied: 'Пустые',
                        settings: 'Настройки',
                        learning: 'Обучение',
                        history: 'История'
                    };

                    const origShowTab = window.showTab;
                    window.showTab = function (tabName) {
                        if (origShowTab) origShowTab(tabName);
                        if (tabTitles[tabName]) {
                            pageTitle.textContent = tabTitles[tabName];
                        } else {
                            pageTitle.textContent = '';
                        }
                    };
                })();

                /* ====== GIH SUMMARY ====== */
                function updateGIHSummary() {
                    const container = document.getElementById("gih-summary");
                    const listEl = document.getElementById("gih-summary-list");
                    if (!container || !listEl) return;

                    // Считаем все продукты
                    const counts = {};
                    (appData.gihRecords || []).forEach(rec => {
                        (rec.products || []).forEach(p => {
                            if (!p || !p.name) return;
                            counts[p.name] = (counts[p.name] || 0) + 1;
                        });
                    });

                    // Если нет данных, скрываем блок
                    const entries = Object.entries(counts);
                    if (entries.length === 0) {
                        container.style.display = "none";
                        listEl.innerHTML = "";
                        return;
                    }

                    // Сортируем по убыванию
                    entries.sort((a, b) => b[1] - a[1]);

                    // Формируем HTML-список
                    const htmlParts = entries.map(([key, count]) => {
                        const name = appData.products[key] || key;
                        return `<div><strong>${name}</strong>  x${count}</div>`;
                    });

                    listEl.innerHTML = htmlParts.join("");
                    container.style.display = "block";
                }


                /* ====== GIH ROOMS SUMMARY (numbers) ====== */
                function updateGIHRoomsSummary() {
                    const cont = document.getElementById('gih-rooms-summary');
                    const list = document.getElementById('gih-rooms-summary-list');
                    const savedEl = document.getElementById('rooms-saved-count');
                    const totalEl = document.getElementById('rooms-total-count');
                    if (!cont || !list) return;

                    const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
                    const total = records.length;
                    const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

                    // counters
                    if (savedEl) savedEl.textContent = String(saved);
                    if (totalEl) totalEl.textContent = String(total);

                    // empty state hides the block (consistently with products summary)
                    if (total === 0) {
                        cont.style.display = 'none';
                        list.innerHTML = '';
                        return;
                    } else {
                        cont.style.display = 'block';
                    }

                    // chips
                    let html = '';
                    records.forEach((rec, i) => {
                        const isSaved = !!rec.savedAt;
                        const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
                        const savedClass = isSaved ? ' saved' : '';
                        html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
                    });
                    list.innerHTML = html;

                    // scroll + flash
                    list.querySelectorAll('.room-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const id = chip.getAttribute('data-id');
                            const card = document.querySelector('.gih-card[data-id="' + id + '"]');
                            if (!card) return;
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.classList.remove('highlighted');
                            void card.offsetWidth; // reflow to restart animation
                            card.classList.add('highlighted');
                            setTimeout(() => card.classList.remove('highlighted'), 800);
                        });
                    });
                }

                // toggle (collapsed/expanded) like products list
                (function initGIHRoomsToggle() {
                    const box = document.getElementById('gih-rooms-summary');
                    const arrow = document.getElementById('gih-rooms-summary-arrow');
                    const list = document.getElementById('gih-rooms-summary-list');
                    if (!box || !arrow || !list) return;

                    let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
                    isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
                    function apply() {
                        box.classList.toggle('collapsed', isCollapsed === 'true');
                        box.classList.toggle('expanded', isCollapsed === 'false');
                        // compute max-height on expand to animate smoothly
                        if (isCollapsed === 'false') {
                            list.style.maxHeight = list.scrollHeight + 'px';
                            list.style.opacity = '1';
                        } else {
                            list.style.maxHeight = '0';
                            list.style.opacity = '0';
                        }
                    }
                    box.addEventListener('click', () => {
                        isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
                        localStorage.setItem('gihRoomsCollapsed', isCollapsed);
                        apply();
                    });
                    apply();
                })();

            </script>
<script>
                // === Фикс перекрытия верхнего блока шапкой ===
                (function () {
                    const header = document.querySelector('header, .mb-header, .mobile-header');
                    const headerHeight = header ? header.offsetHeight : 0;

                    const origShowTab = window.showTab;
                    window.showTab = function (tabName) {
                        if (origShowTab) origShowTab(tabName);
                        // Прокрутка так, чтобы шапка не перекрывала контент
                        setTimeout(() => {
                            window.scrollTo({
                                top: 0,
                                behavior: 'instant'
                            });
                        }, 50);
                    };
                })();

                /* ====== GIH SUMMARY ====== */
                function updateGIHSummary() {
                    const container = document.getElementById("gih-summary");
                    const listEl = document.getElementById("gih-summary-list");
                    if (!container || !listEl) return;

                    // Считаем все продукты
                    const counts = {};
                    (appData.gihRecords || []).forEach(rec => {
                        (rec.products || []).forEach(p => {
                            if (!p || !p.name) return;
                            counts[p.name] = (counts[p.name] || 0) + 1;
                        });
                    });

                    // Если нет данных, скрываем блок
                    const entries = Object.entries(counts);
                    if (entries.length === 0) {
                        container.style.display = "none";
                        listEl.innerHTML = "";
                        return;
                    }

                    // Сортируем по убыванию
                    entries.sort((a, b) => b[1] - a[1]);

                    // Формируем HTML-список
                    const htmlParts = entries.map(([key, count]) => {
                        const name = appData.products[key] || key;
                        return `<div><strong>${name}</strong>  x${count}</div>`;
                    });

                    listEl.innerHTML = htmlParts.join("");
                    container.style.display = "block";
                }


                /* ====== GIH ROOMS SUMMARY (numbers) ====== */
                function updateGIHRoomsSummary() {
                    const cont = document.getElementById('gih-rooms-summary');
                    const list = document.getElementById('gih-rooms-summary-list');
                    const savedEl = document.getElementById('rooms-saved-count');
                    const totalEl = document.getElementById('rooms-total-count');
                    if (!cont || !list) return;

                    const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
                    const total = records.length;
                    const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

                    // counters
                    if (savedEl) savedEl.textContent = String(saved);
                    if (totalEl) totalEl.textContent = String(total);

                    // empty state hides the block (consistently with products summary)
                    if (total === 0) {
                        cont.style.display = 'none';
                        list.innerHTML = '';
                        return;
                    } else {
                        cont.style.display = 'block';
                    }

                    // chips
                    let html = '';
                    records.forEach((rec, i) => {
                        const isSaved = !!rec.savedAt;
                        const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
                        const savedClass = isSaved ? ' saved' : '';
                        html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
                    });
                    list.innerHTML = html;

                    // scroll + flash
                    list.querySelectorAll('.room-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const id = chip.getAttribute('data-id');
                            const card = document.querySelector('.gih-card[data-id="' + id + '"]');
                            if (!card) return;
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.classList.remove('highlighted');
                            void card.offsetWidth; // reflow to restart animation
                            card.classList.add('highlighted');
                            setTimeout(() => card.classList.remove('highlighted'), 800);
                        });
                    });
                }

                // toggle (collapsed/expanded) like products list
                (function initGIHRoomsToggle() {
                    const box = document.getElementById('gih-rooms-summary');
                    const arrow = document.getElementById('gih-rooms-summary-arrow');
                    const list = document.getElementById('gih-rooms-summary-list');
                    if (!box || !arrow || !list) return;

                    let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
                    isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
                    function apply() {
                        box.classList.toggle('collapsed', isCollapsed === 'true');
                        box.classList.toggle('expanded', isCollapsed === 'false');
                        // compute max-height on expand to animate smoothly
                        if (isCollapsed === 'false') {
                            list.style.maxHeight = list.scrollHeight + 'px';
                            list.style.opacity = '1';
                        } else {
                            list.style.maxHeight = '0';
                            list.style.opacity = '0';
                        }
                    }
                    box.addEventListener('click', () => {
                        isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
                        localStorage.setItem('gihRoomsCollapsed', isCollapsed);
                        apply();
                    });
                    apply();
                })();

            </script>
<script>
                // === Переопределение showTab без автопрокрутки ===
                (function () {
                    window.showTab = function (tab) {
                        var $ = (sel) => document.querySelector(sel);
                    // Скрываем все секции
                    ['accises', 'sroki', 'gih', 'dispatchers'].forEach(function (name) {
                        var el = document.getElementById(name + '-section');
                        if (el) el.classList.toggle('hidden', name !== tab);
                    });
                        // Обновляем состояние навигации
                        try { syncBottomNav(tab); } catch (e) { }
                        try { syncTopNav(tab); } catch (e) { }
                        // Не скроллим страницу
                    };
                })();

                /* ====== GIH SUMMARY ====== */
                function updateGIHSummary() {
                    const container = document.getElementById("gih-summary");
                    const listEl = document.getElementById("gih-summary-list");
                    if (!container || !listEl) return;

                    // Считаем все продукты
                    const counts = {};
                    (appData.gihRecords || []).forEach(rec => {
                        (rec.products || []).forEach(p => {
                            if (!p || !p.name) return;
                            counts[p.name] = (counts[p.name] || 0) + 1;
                        });
                    });

                    // Если нет данных, скрываем блок
                    const entries = Object.entries(counts);
                    if (entries.length === 0) {
                        container.style.display = "none";
                        listEl.innerHTML = "";
                        return;
                    }

                    // Сортируем по убыванию
                    entries.sort((a, b) => b[1] - a[1]);

                    // Формируем HTML-список
                    const htmlParts = entries.map(([key, count]) => {
                        const name = appData.products[key] || key;
                        return `<div><strong>${name}</strong>  x${count}</div>`;
                    });

                    listEl.innerHTML = htmlParts.join("");
                    container.style.display = "block";
                }


                // --- Свернуть/Развернуть список продуктов: клик по блоку, стрелка-индикатор (фикс) ---
                document.addEventListener("DOMContentLoaded", () => {
                    const summary = document.getElementById("gih-summary");
                    const list = document.getElementById("gih-summary-list");
                    const arrow = document.getElementById("gih-summary-arrow");
                    if (!summary || !list || !arrow) return;

                    // Начальное состояние: читаем из localStorage, по умолчанию свернуто
                    let isCollapsedStored = localStorage.getItem("gihSummaryCollapsed");
                    let isCollapsed = isCollapsedStored === null ? true : (isCollapsedStored === "true");

                    function apply() {
                        summary.classList.toggle("collapsed", isCollapsed);
                        summary.classList.toggle("expanded", !isCollapsed);
                    }

                    // Обработчик клика по блоку
                    summary.addEventListener("click", () => {
                        isCollapsed = !isCollapsed;
                        localStorage.setItem("gihSummaryCollapsed", String(isCollapsed));
                        apply();
                    });

                    // Инициализация
                    apply();
                });


                /* ====== GIH ROOMS SUMMARY (numbers) ====== */
                function updateGIHRoomsSummary() {
                    const cont = document.getElementById('gih-rooms-summary');
                    const list = document.getElementById('gih-rooms-summary-list');
                    const savedEl = document.getElementById('rooms-saved-count');
                    const totalEl = document.getElementById('rooms-total-count');
                    if (!cont || !list) return;

                    const records = (appData && appData.gihRecords) ? appData.gihRecords : [];
                    const total = records.length;
                    const saved = records.filter(r => r && r.savedAt).length; // считаем по savedAt

                    // counters
                    if (savedEl) savedEl.textContent = String(saved);
                    if (totalEl) totalEl.textContent = String(total);

                    // empty state hides the block (consistently with products summary)
                    if (total === 0) {
                        cont.style.display = 'none';
                        list.innerHTML = '';
                        return;
                    } else {
                        cont.style.display = 'block';
                    }

                    // chips
                    let html = '';
                    records.forEach((rec, i) => {
                        const isSaved = !!rec.savedAt;
                        const label = (rec && (rec.room || rec.number)) ? (rec.room || rec.number) : ('#' + (i + 1));
                        const savedClass = isSaved ? ' saved' : '';
                        html += '<div class="room-chip' + savedClass + '" data-id="' + rec.id + '">' + label + '</div>';
                    });
                    list.innerHTML = html;

                    // scroll + flash
                    list.querySelectorAll('.room-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const id = chip.getAttribute('data-id');
                            const card = document.querySelector('.gih-card[data-id="' + id + '"]');
                            if (!card) return;
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.classList.remove('highlighted');
                            void card.offsetWidth; // reflow to restart animation
                            card.classList.add('highlighted');
                            setTimeout(() => card.classList.remove('highlighted'), 800);
                        });
                    });
                }

                // toggle (collapsed/expanded) like products list
                (function initGIHRoomsToggle() {
                    const box = document.getElementById('gih-rooms-summary');
                    const arrow = document.getElementById('gih-rooms-summary-arrow');
                    const list = document.getElementById('gih-rooms-summary-list');
                    if (!box || !arrow || !list) return;

                    let isCollapsed = localStorage.getItem('gihRoomsCollapsed');
                    isCollapsed = (isCollapsed === null) ? 'true' : isCollapsed; // collapsed by default
                    function apply() {
                        box.classList.toggle('collapsed', isCollapsed === 'true');
                        box.classList.toggle('expanded', isCollapsed === 'false');
                        // compute max-height on expand to animate smoothly
                        if (isCollapsed === 'false') {
                            list.style.maxHeight = list.scrollHeight + 'px';
                            list.style.opacity = '1';
                        } else {
                            list.style.maxHeight = '0';
                            list.style.opacity = '0';
                        }
                    }
                    box.addEventListener('click', () => {
                        isCollapsed = (isCollapsed === 'true') ? 'false' : 'true';
                        localStorage.setItem('gihRoomsCollapsed', isCollapsed);
                        apply();
                    });
                    apply();
                })();

            </script>
<script>
                /* === Расширенное переключение вкладок (включая extra) === */
                (function () {
                    const $ = s => document.querySelector(s);
                    const $$ = s => Array.from(document.querySelectorAll(s));

                    /* Карта имён вкладок -> секций */
                    const tabMap = {
                        accises: $('#accises-section'),
                        sroki: $('#sroki-section'),
                        gih: $('#gih-section'),
                        dispatchers: $('#dispatchers-section'),
                        emptied: $('#emptied-section'),
                        settings: $('#settings-section'),
                        learning: $('#learning-section'),
                        practice: $('#practice-section'),
                        history: $('#history-section')
                    };

                    /* Скрыть все секции */
                    function hideAll() {
                        Object.values(tabMap).forEach(el => el && el.classList.add('hidden'));
                    }

                    /* Показать нужную секцию */
                    function showTab(tab) {
                        hideAll();
                        const target = tabMap[tab];
                        if (target) target.classList.remove('hidden');

                        /* синхронизируем навигацию */
                        $$('.nav-item, .b-item, .mb-burger-item').forEach(n =>
                            n.classList.toggle('active', n.dataset.tab === tab)
                        );

                        /* закрываем бургер-меню */
                        $('#mbBurgerMenu')?.classList.remove('show');
                        
                        /* Инициализируем депатчеры при переключении на вкладку */
                        if (tab === 'dispatchers' && typeof window.dispatchersInit === 'function') {
                            setTimeout(window.dispatchersInit, 100);
                        }
                        /* Инициализируем пустые при переключении на вкладку */
                        if (tab === 'emptied' && typeof window.emptiedInit === 'function') {
                            setTimeout(window.emptiedInit, 100);
                        }
                    }

                    /* Вешаем клики на все переключатели */
                    document.addEventListener('click', e => {
                        const tab = e.target.closest('[data-tab]')?.dataset.tab;
                        if (tab) {
                            e.preventDefault();
                            showTab(tab);
                        }
                    });

                    /* При старте показываем акцизы */
                    document.addEventListener('DOMContentLoaded', () => showTab('accises'));
                })();
            </script>
<script>
                // Auto-set current date in GIH header
                (function () {
                    const el = document.getElementById('gih-title-date');
                    if (!el) return;
                    const today = new Date();
                    const dd = String(today.getDate()).padStart(2, '0');
                    const mm = String(today.getMonth() + 1).padStart(2, '0');
                    const yy = String(today.getFullYear()).slice(-2);
                    el.textContent = `GIH ${dd}.${mm}.${yy}`;
                })();
            </script>
<script>
                // --- Persist active tab across reloads ---
                (function () {
                    const STORAGE_KEY = 'minibar-active-tab';

                    // 1. Запоминаем вкладку при каждом её переключении
                    const originalShowTab = window.showTab;
                    window.showTab = function (tab) {
                        if (typeof originalShowTab === 'function') originalShowTab(tab);
                        localStorage.setItem(STORAGE_KEY, tab);
                    };

                    // 2. Читаем сохранённое значение и показываем нужную вкладку при загрузке
                    document.addEventListener('DOMContentLoaded', () => {
                        const savedTab = localStorage.getItem(STORAGE_KEY) || 'accises'; // fallback
                        window.showTab(savedTab);

                        // синхронизируем состояние навигаций
                        if (typeof syncTopNav === 'function') syncTopNav(savedTab);
                        if (typeof syncBottomNav === 'function') syncBottomNav(savedTab);
                    });
                })();
                /* ---------- Unified tab switcher ---------- */
                (() => {
                    const $ = s => document.querySelector(s);
                    const $$ = s => Array.from(document.querySelectorAll(s));

                    const sections = [
                        'accises-section', 'sroki-section', 'gih-section', 'dispatchers-section', 'emptied-section', 'settings-section', 'learning-section', 'history-section'
                    ];

                    function hideAll() {
                        sections.forEach(id => {
                            const el = document.getElementById(id);
                            if (el) el.classList.remove('show');
                        });
                    }

                    function showTab(tab) {
                        hideAll();
                        document.getElementById(tab + '-section')?.classList.add('show');

                        // sync top / bottom / burger
                        $$('.nav-item, .b-item, .mb-burger-item').forEach(n =>
                            n.classList.toggle('active', n.dataset.tab === tab)
                        );
                        $('#mbBurgerMenu')?.classList.remove('show');
                    }

                    // initial tab
                    document.addEventListener('DOMContentLoaded', () => {
                        const active = localStorage.getItem('minibar-active-tab') || 'accises';
                        showTab(active);
                    });

                    // clicks
                    document.addEventListener('click', e => {
                        const tab = e.target.closest('[data-tab]')?.dataset.tab;
                        if (tab) {
                            e.preventDefault();
                            showTab(tab);
                            localStorage.setItem('minibar-active-tab', tab);
                        }
                    });
                })();


                document.addEventListener("DOMContentLoaded", () => {
                    const dateInput = document.getElementById("history-date");
                    if (dateInput) {
                        const today = new Date().toISOString().split("T")[0];
                        dateInput.setAttribute("max", today);
                        dateInput.value = today;
                    }

                    dateInput?.addEventListener("change", (e) => {
                        const selectedDate = e.target.value;
                        const historyList = document.getElementById("history-list");

                        historyList.innerHTML = `<div style="background:#f8f9fa; padding:15px; border-radius:10px; font-size:14px;">Записи за ${selectedDate}</div>`;
                    });
                });

            </script>
<!-- GIH Saved Patch BEGIN -->
<script>

                (function () {
                    'use strict';
                    var db = (window.firebase && firebase.database) ? firebase.database() : null;
                    var savedIds = new Set();

                    function q(sel, root) { return (root || document).querySelector(sel); }
                    function qa(sel, root) { return Array.from((root || document).querySelectorAll(sel)); }

                    function selectById(id) {
                        return '.gih-card[data-id="' + id + '"], .gih-card[data-key="' + id + '"]';
                    }

                    function getCardId(card) {
                        if (!card) return '';
                        return card.dataset.id || card.getAttribute('data-id') || card.getAttribute('data-key') || '';
                    }

                    function ui() {
                        return {
                            main: q('#gih-records'),
                            saved: q('#gih-saved-records'),
                            divider: q('#gih-divider')
                        };
                    }

                    function updateDivider() {
                        var U = ui();
                        if (U.divider) U.divider.style.display = (U.saved && U.saved.querySelector('.gih-card')) ? 'block' : 'none';
                    }

                    function moveToSaved(card) {
                        var U = ui();
                        if (!U.saved || !card) return;
                        var id = getCardId(card);
                        if (!id) return;

                        // 1) Удаляем любые другие копии этой карточки (и в сохранённых, и в основном списке), кроме текущей
                        qa(selectById(id)).forEach(function (node) {
                            if (node !== card && node.parentElement) node.parentElement.removeChild(node);
                        });

                        // 2) Если текущая карточка уже в сохранённых — просто обновим состояние, без повторного перемещения
                        if (!U.saved.contains(card)) {
                            U.saved.appendChild(card);
                        }

                        // 3) Отмечаем как сохранённую локально, чтобы наблюдатель не трогал её
                        savedIds.add(id);

                        // 4) Деактивируем кнопку "Сохранить"
                        var btn = card.querySelector('.card-save');
                        if (btn) btn.disabled = true;

                        updateDivider();
                    }

                    function markSavedInDb(id, onDone) {
                        if (!db || !id) { onDone && onDone(); return; }
                        db.ref('gihRecords/' + id).update({ saved: true }).then(function () {
                            savedIds.add(id);
                            onDone && onDone();
                        }).catch(function () { onDone && onDone(); });
                    }

                    function handleSaveClick(e) {
                        var btn = e.target.closest('.card-save');
                        if (!btn) return;
                        var card = btn.closest('.gih-card');
                        if (!card) return;
                        var id = getCardId(card);
                        if (!id) return;

                        // Локально помечаем и переносим (без дублей), параллельно обновляем Firebase
                        savedIds.add(id);
                        moveToSaved(card);
                        markSavedInDb(id);
                    }

                    function bindClicks() {
                        document.removeEventListener('click', handleSaveClick);
                        document.addEventListener('click', handleSaveClick);
                    }

                    // Наблюдаем за новым контентом в основном списке
                    function watchMainList() {
                        var U = ui();
                        if (!U.main) return;
                        var mo = new MutationObserver(function (muts) {
                            muts.forEach(function (m) {
                                (m.addedNodes || []).forEach(function (node) {
                                    if (!(node instanceof HTMLElement)) return;
                                    var card = node.matches && node.matches('.gih-card') ? node : (node.querySelector && node.querySelector('.gih-card'));
                                    if (!card) return;
                                    var id = getCardId(card);
                                    if (!id) return;

                                    // Если карточка уже отмечена как сохранённая — переносим, а другие копии с тем же id удаляем
                                    if (savedIds.has(id)) { moveToSaved(card); return; }

                                    // Проверяем Firebase на случай внешнего сохранения
                                    if (db) {
                                        db.ref('gihRecords/' + id + '/saved').once('value').then(function (snap) {
                                            if (snap.val()) { savedIds.add(id); moveToSaved(card); }
                                        });
                                    }
                                });
                            });
                            updateDivider();
                        });
                        mo.observe(U.main, { childList: true, subtree: true });
                    }

                    // Слушаем изменения Firebase и переносим только если карточка ещё не перенесена
                    function listenDbChanges() {
                        if (!db) return;
                        db.ref('gihRecords').on('child_added', function (snap) {
                            var val = snap.val() || {};
                            var id = snap.key;
                            if (val.saved) {
                                savedIds.add(id);
                                var card = q(selectById(id));
                                if (card) moveToSaved(card);
                            }
                        });
                        db.ref('gihRecords').on('child_changed', function (snap) {
                            var val = snap.val() || {};
                            var id = snap.key;
                            if (val.saved) {
                                savedIds.add(id);
                                var card = q(selectById(id));
                                if (card) moveToSaved(card);
                            }
                        });
                    }

                    function init() {
                        bindClicks();
                        watchMainList();
                        listenDbChanges();
                        updateDivider();
                    }

                    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
                    else init();
                })();

            </script>
<!-- GIH Saved Patch END -->
<!-- GIH Products Summary Filter (exclude saved) BEGIN -->
<script>
                (function () {
                    function updateGIHSummary() {
                        const container = document.getElementById("gih-summary");
                        const listEl = document.getElementById("gih-summary-list");
                        if (!container || !listEl) return;

                        const main = document.getElementById("gih-records");
                        if (!main) return;

                        // Собираем продукты только из несохранённых карточек
                        const counts = {};
                        const cards = main.querySelectorAll(".gih-card");
                        cards.forEach(card => {
                            const products = card.querySelectorAll(".gih-product");
                            products.forEach(p => {
                                const name = p.textContent.trim();
                                if (!name) return;
                                counts[name] = (counts[name] || 0) + 1;
                            });
                        });

                        // Сортируем по количеству по убыванию
                        const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);

                        if (entries.length === 0) {
                            container.style.display = 'none';
                            listEl.innerHTML = '';
                            return;
                        }

                        listEl.innerHTML = entries
                            .map(([name, count]) => `<div><strong>${name}</strong> x${count}</div>`)
                            .join("");

                        container.style.display = 'block';
                    }

                    // Следим за изменениями в карточках
                    function observeChanges() {
                        const main = document.getElementById("gih-records");
                        const saved = document.getElementById("gih-saved-records");
                        const opts = { childList: true, subtree: true };

                        if (main) new MutationObserver(updateGIHSummary).observe(main, opts);
                        if (saved) new MutationObserver(updateGIHSummary).observe(saved, opts);

                        document.addEventListener("click", e => {
                            if (e.target.closest(".card-save") || e.target.closest(".delete-btn")) {
                                setTimeout(updateGIHSummary, 50);
                            }
                        });
                    }

                    if (document.readyState === "loading") {
                        document.addEventListener("DOMContentLoaded", () => {
                            observeChanges();
                            updateGIHSummary();
                        });
                    } else {
                        observeChanges();
                        updateGIHSummary();
                    }
                })();
            </script>
<!-- GIH Products Summary Filter (exclude saved) END -->
<script>
                (function () {
                    const STORAGE_KEY = 'minibar-active-tab';
                    const sections = [
                        'accises', 'sroki', 'gih', 'dispatchers', 'emptied',
                        'settings', 'learning', 'history'
                    ];

                    function hideAll() {
                        sections.forEach(name => {
                            const el = document.getElementById(name + '-section');
                            if (el) el.classList.add('hidden');
                        });
                    }

                    window.showTab = function (tab) {
                        hideAll();
                        const target = document.getElementById(tab + '-section');
                        if (target) target.classList.remove('hidden');

                        // синхронизация активных кнопок
                        document.querySelectorAll('.nav-item, .b-item, .mb-burger-item')
                            .forEach(n => n.classList.toggle('active', n.dataset.tab === tab));

                        // закрыть бургер-меню
                        document.getElementById('mbBurgerMenu')?.classList.remove('show');

                        // сохранить
                        localStorage.setItem(STORAGE_KEY, tab);
                    };

                    document.addEventListener('click', e => {
                        const tab = e.target.closest('[data-tab]')?.dataset.tab;
                        if (tab) {
                            e.preventDefault();
                            showTab(tab);
                        }
                    });

                    document.addEventListener('DOMContentLoaded', () => {
                        const saved = localStorage.getItem(STORAGE_KEY) || 'accises';
                        showTab(saved);
                    });
                })();
            </script>
<script>
                /* === Полноценный поиск по номеру в Истории === */
                (function () {
                    const btnSearch = document.getElementById('history-search-btn');
                    const btnClear = document.getElementById('history-search-clear');
                    btnClear.style.display = 'none';
                    const inp = document.getElementById('history-search-input');
                    const dateRow = document.getElementById('history-date-row');
                    const list = document.getElementById('history-list');

                    if (!btnSearch || !btnClear || !inp || !dateRow || !list) return;

                    let searchMode = false;

                    /* ----- UI helpers ----- */
                    function enterSearchMode() {
                        inp.style.width = '120px';
                        inp.style.opacity = '1';
                        dateRow.style.display = 'none';
                        inp.focus();
                        btnClear.style.display = 'inline'; // Показываем кнопку-крутик только после того, как поле поиска стало видимым

                    }

                    function exitSearchMode() {
                        const historyList = document.getElementById("history-list");
                        inp.style.width = '0';
                        inp.style.opacity = '0';
                        inp.value = '';
                        dateRow.style.display = 'flex';
                        btnClear.style.display = 'none'; // Скрываем кнопку-крутик
                        historyList.classList.remove("search-active");
                        renderHistory();
                    }

                    function clearSearch() {
                        exitSearchMode(); // Выходим из режима поиска
                    }

                    /* ----- Поиск и рендер ----- */
                    function escapeRegExp(str) {
                        return str.replace(/[.*+?^${}()|\[$$ \\]/g, '\\$&');
                    }

                    function renderSearchResults(query) {
                        const historyList = document.getElementById("history-list");
                        const cleanQuery = query.trim();
                        if (!cleanQuery) { renderHistory(); return; }

                        const regex = new RegExp('\\b' + escapeRegExp(cleanQuery) + '\\b', 'i');

                        /* фильтруем по всей истории */
                        const matched = (appData.gihHistory || []).filter(entry =>
                            regex.test(entry.room || entry.number || '')
                        );

                        if (matched.length === 0) {
                            list.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">Ничего не найдено</div>';
                            return;
                        }

                        /* группируем по дате создания (createdAt) */
                        const byDate = {};
                        matched.forEach(entry => {
                            const date = new Date(entry.createdAt).toLocaleDateString('ru-RU');
                            (byDate[date] = byDate[date] || []).push(entry);
                        });

                        historyList.classList.add("search-active");
                        /* рендерим аналогично renderHistory, но за все даты */
                        list.innerHTML = '';
                        Object.keys(byDate).sort((a, b) => new Date(b.split('.').reverse().join('-')) - new Date(a.split('.').reverse().join('-')))
                            .forEach(date => {
                                const header = document.createElement('div');
                                header.className = 'history-date-header';
                                header.textContent = date;
                                list.appendChild(header);

                                byDate[date].forEach(entry => list.appendChild(buildHistoryCard(entry)));
                            });
                    }

                    /* ----- строим карточку найденной записи (копия renderHistory) ----- */
                    function buildHistoryCard(entry) {
                        const card = document.createElement('div');
                        card.className = 'gih-card';
                        card.style.marginBottom = '10px';

                        const headerHtml = `
                                          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                                            <div style="font-weight:700;color:var(--primary-strong)">${entry.room}</div>
                                            <div class="muted" style="font-weight:700">${entry.savedAt}</div>
                                          </div>`;

                        let contentHtml = '';

                        if (entry.statusMode) {
                            const modeLabels = { dnd: 'DND', allInPlace: 'Всё на месте', putOut: 'Всё выложили', emptied: 'Опустошён' };
                            const groups = {};
                            (entry.products || []).forEach(p => { groups[p.name] = (groups[p.name] || 0) + 1; });
                            const list = Object.entries(groups).map(([k, c]) => `${appData.products[k] || k}${c > 1 ? ` x${c}` : ''}`).join(', ');
                            contentHtml = `<div class="muted" style="margin-bottom:6px;">${list}</div>
                                                         <div style="font-weight:600;margin-top:8px;">${modeLabels[entry.statusMode] || entry.statusMode}</div>`;
                        } else {
                            const byStatus = { 1: {}, 2: {}, 3: {}, 4: {} };
                            (entry.products || []).forEach(p => {
                                const st = Number(p.status || 0);
                                const nm = appData.products[p.name] || p.name;
                                byStatus[st][nm] = (byStatus[st][nm] || 0) + 1;
                            });
                            const labels = { 1: 'Пополнено', 2: 'На месте', 3: 'Выложили', 4: 'Не пополнено' };
                            const cls = { 1: 't-added', 2: 't-here', 3: 't-out', 4: 't-miss' };
                            [1, 2, 3, 4].forEach(st => {
                                const items = Object.entries(byStatus[st]).map(([n, c]) => c > 1 ? `${n} x${c}` : n).join(', ');
                                if (items) contentHtml += `
                                              <div style="margin-bottom:8px;">
                                                <div class="${cls[st]}" style="font-weight:700;font-size:13px">${labels[st]}:</div>
                                                <div class="muted" style="margin-top:4px">${items}</div>
                                              </div>`;
                            });
                        }
                        if (entry.comment) {
                            contentHtml += `<div style="margin-top:8px;">
                                            <div class="muted" style="font-weight:700;font-size:13px">Комментарий: <span class="muted" style="font-weight:400">${entry.comment}</span></div>
                                          </div>`;
                        }

                        card.innerHTML = headerHtml + contentHtml;
                        return card;
                    }

                    /* ----- события ----- */
                    btnSearch.addEventListener('click', enterSearchMode);
                    btnClear.addEventListener('click', clearSearch);
                    inp.addEventListener('input', () => renderSearchResults(inp.value));
                    inp.addEventListener('blur', () => {
                        if (!inp.value.trim()) exitSearchMode();
                    });
                    inp.addEventListener('keydown', e => {
                        if (e.key === 'Escape') { exitSearchMode(); }
                    });
                })();
            </script>
<script>
                /* Делаем номера комнат в карточках GIH и Истории кликабельными */
                (function () {
                    /* Выполняем поиск по номеру */
                    function searchByRoom(room) {
                        window.showTab('history');                       // переходим в Историю
                        const inp = document.getElementById('history-search-input');
                        if (!inp) return;
                        inp.value = room;                                // вставляем номер
                        inp.dispatchEvent(new Event('input', { bubbles: true })); // запускаем поиск

                        // показываем поле поиска, если было свернуто
                        inp.style.width = '120px';
                        inp.style.opacity = '1';
                        document.getElementById('history-search-clear').style.display = 'inline-flex';
                        document.getElementById('history-date-row').style.display = 'none';
                    }

                    /* Превращаем текстовый номер в <a> без подчёркивания */
                    function convertCard(card) {
                        const roomEl = card.querySelector('.room-number, .gih-card > div > div');
                        if (!roomEl || roomEl.querySelector('a.room-link')) return; // уже обработано

                        const room = roomEl.textContent.trim();
                        if (!room) return;

                        roomEl.innerHTML = '';                 // очищаем текст
                        const a = document.createElement('a');
                        a.href = '#';
                        a.className = 'room-link';
                        a.textContent = room;
                        a.style.color = 'var(--primary-strong)';
                        a.style.cursor = 'pointer';
                        a.style.textDecoration = 'none';      // убираем подчёркивание
                        a.addEventListener('click', e => {
                            e.preventDefault();
                            searchByRoom(room);
                        });
                        roomEl.appendChild(a);
                    }

                    /* Отслеживаем появление новых карточек */
                    const lists = ['#gih-records', '#gih-saved-records', '#history-list'];
                    lists.forEach(selector => {
                        const root = document.querySelector(selector);
                        if (!root) return;

                        new MutationObserver(() => {
                            root.querySelectorAll('.gih-card').forEach(convertCard);
                        }).observe(root, { childList: true, subtree: true });

                        // первичная обработка уже существующих карточек
                        root.querySelectorAll('.gih-card').forEach(convertCard);
                    });
                })();
            </script>
<script>
                // ==== Accordion Logic ====
                document.querySelectorAll('.accordion-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        header.classList.toggle('active');
                        content.classList.toggle('open');
                    });
                });
            </script>
<script>
// === КАСТОМНЫЙ КАЛЕНДАРЬ ===
class CustomCalendar {
    constructor() {
        this.currentDate = new Date();
        this.selectedDate = new Date();
        this.maxDate = new Date(); // сегодня
        this.init();
    }

    init() {
        this.createDOM();
        this.bindEvents();
    }

    createDOM() {
        // Создаем overlay
        this.overlay = document.createElement('div');
        this.overlay.className = 'custom-calendar-overlay';
        
        // Создаем календарь
        this.calendar = document.createElement('div');
        this.calendar.className = 'custom-calendar';
        
        // Шаблон календаря
        this.calendar.innerHTML = `
            <div class="custom-calendar-header">
                <div class="custom-calendar-title"></div>
                <div class="custom-calendar-nav">
                    <button class="custom-calendar-nav-btn prev-year" title="Предыдущий год">
                        <i class="fas fa-angle-double-left"></i>
                    </button>
                    <button class="custom-calendar-nav-btn prev-month" title="Предыдущий месяц">
                        <i class="fas fa-angle-left"></i>
                    </button>
                    <button class="custom-calendar-nav-btn next-month" title="Следующий месяц">
                        <i class="fas fa-angle-right"></i>
                    </button>
                    <button class="custom-calendar-nav-btn next-year" title="Следующий год">
                        <i class="fas fa-angle-double-right"></i>
                    </button>
                </div>
            </div>
            <div class="custom-calendar-weekdays">
                <div class="custom-calendar-weekday">Пн</div>
                <div class="custom-calendar-weekday">Вт</div>
                <div class="custom-calendar-weekday">Ср</div>
                <div class="custom-calendar-weekday">Чт</div>
                <div class="custom-calendar-weekday">Пт</div>
                <div class="custom-calendar-weekday">Сб</div>
                <div class="custom-calendar-weekday">Вс</div>
            </div>
            <div class="custom-calendar-days"></div>
            <div class="custom-calendar-footer">
                <button class="btn ghost small today-btn">Сегодня</button>
                <button class="btn ghost small cancel-btn">Закрыть</button>
            </div>
        `;
        
        this.overlay.appendChild(this.calendar);
        document.body.appendChild(this.overlay);
        
        // Сохраняем ссылки на элементы
        this.titleEl = this.calendar.querySelector('.custom-calendar-title');
        this.daysContainer = this.calendar.querySelector('.custom-calendar-days');
        this.todayBtn = this.calendar.querySelector('.today-btn');
        this.cancelBtn = this.calendar.querySelector('.cancel-btn');
    }

    bindEvents() {
        // Навигация
        this.calendar.querySelector('.prev-year').addEventListener('click', () => this.changeYear(-1));
        this.calendar.querySelector('.prev-month').addEventListener('click', () => this.changeMonth(-1));
        this.calendar.querySelector('.next-month').addEventListener('click', () => this.changeMonth(1));
        this.calendar.querySelector('.next-year').addEventListener('click', () => this.changeYear(1));
        
        // Кнопки
        this.todayBtn.addEventListener('click', () => this.goToToday());
        this.cancelBtn.addEventListener('click', () => this.hide());
        
        // Закрытие по клику вне календаря
        this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) {
                this.hide();
            }
        });
        
        // Закрытие по Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.overlay.classList.contains('show')) {
                this.hide();
            }
        });
    }

    changeMonth(delta) {
        this.currentDate.setMonth(this.currentDate.getMonth() + delta);
        this.render();
    }

    changeYear(delta) {
        this.currentDate.setFullYear(this.currentDate.getFullYear() + delta);
        this.render();
    }

    goToToday() {
        const today = new Date();
        this.selectDate(today.getDate(), today.getMonth(), today.getFullYear(), true);
    }

    // Функция для подсчета записей за конкретную дату
    getRecordsCountForDate(date) {
        if (!appData.gihHistory || !Array.isArray(appData.gihHistory)) return 0;
        
        const targetDateString = date.toLocaleDateString('ru-RU');
        return appData.gihHistory.filter(record => {
            if (!record.createdAt) return false;
            const recordDate = new Date(record.createdAt);
            const recordDateString = recordDate.toLocaleDateString('ru-RU');
            return recordDateString === targetDateString;
        }).length;
    }

    render() {
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        
        // Обновляем заголовок
        const monthNames = [
            'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
            'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
        ];
        this.titleEl.textContent = `${monthNames[month]} ${year}`;
        
        // Очищаем дни
        this.daysContainer.innerHTML = '';
        
        // Первый день месяца и день недели
        const firstDay = new Date(year, month, 1);
        const startingDay = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1; // Пн=0, Вс=6
        
        // Последний день месяца
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        
        // Дни предыдущего месяца
        const prevMonthLastDay = new Date(year, month, 0).getDate();
        
        // Сегодняшняя дата для сравнения
        const today = new Date();
        const todayString = today.toDateString();
        
        // Выбранная дата для сравнения
        const selectedString = this.selectedDate.toDateString();
        
        // Заполняем календарь
        let dayCount = 1;
        
        for (let i = 0; i < 42; i++) { // 6 недель
            const dayEl = document.createElement('button');
            dayEl.className = 'custom-calendar-day';
            
            let dayNumber, isCurrentMonth, date;
            
            if (i < startingDay) {
                // Дни предыдущего месяца
                dayNumber = prevMonthLastDay - startingDay + i + 1;
                date = new Date(year, month - 1, dayNumber);
                isCurrentMonth = false;
            } else if (dayCount <= daysInMonth) {
                // Дни текущего месяца
                dayNumber = dayCount;
                date = new Date(year, month, dayCount);
                isCurrentMonth = true;
                dayCount++;
            } else {
                // Дни следующего месяца
                dayNumber = i - startingDay - daysInMonth + 1;
                date = new Date(year, month + 1, dayNumber);
                isCurrentMonth = false;
            }
            
            dayEl.textContent = dayNumber;
            const dateString = date.toDateString();
            
            // Определяем классы для дня
            if (!isCurrentMonth) {
                dayEl.classList.add('other-month');
            }
            
            if (dateString === todayString) {
                dayEl.classList.add('today');
            }
            
            if (dateString === selectedString) {
                dayEl.classList.add('selected');
            }
            
            // Проверяем, не будущая ли дата
            if (date > this.maxDate) {
                dayEl.classList.add('disabled');
            } else {
                // Для дней текущего месяца добавляем обработчик
                if (isCurrentMonth) {
                    dayEl.addEventListener('click', () => {
                        this.selectDate(dayNumber, month, year, true);
                    });
                } else {
                    // Для дней другого месяца - переключаемся на этот месяц
                    dayEl.addEventListener('click', () => {
                        this.selectDateFromOtherMonth(dayNumber, date);
                    });
                }
                
                // Добавляем счетчик записей для всех дней (кроме будущих)
                const recordsCount = this.getRecordsCountForDate(date);
                if (recordsCount > 0) {
                    const countBadge = document.createElement('div');
                    countBadge.className = 'day-record-count';
                    countBadge.textContent = recordsCount; // Всегда полное число
                    countBadge.title = `${recordsCount} записей за этот день`;
                    dayEl.appendChild(countBadge);
                }
            }
            
            this.daysContainer.appendChild(dayEl);
        }
    }

    selectDate(day, month, year, isCurrentMonth = true) {
        this.selectedDate = new Date(year, month, day);
        
        // Применяем выбранную дату сразу
        if (this.onDateSelect) {
            this.onDateSelect(this.selectedDate);
        }
        this.hide();
    }

    selectDateFromOtherMonth(day, date) {
        // При клике на день другого месяца переключаемся на этот месяц
        this.currentDate = new Date(date);
        this.selectedDate = new Date(date);
        this.render();
        selectDate(day,date.month,date.year);
        // Не применяем дату сразу, пользователь может выбрать другую дату в этом месяце
    }

    show(currentDate = new Date(), onDateSelect = null) {
        this.currentDate = new Date(currentDate);
        this.selectedDate = new Date(currentDate);
        this.onDateSelect = onDateSelect;
        this.render();
        
        // Добавляем класс к body чтобы скрыть нативный календарь
        document.body.classList.add('custom-calendar-open');
        this.overlay.classList.add('show');
    }

    hide() {
        document.body.classList.remove('custom-calendar-open');
        this.overlay.classList.remove('show');
    }
}

// Инициализация кастомного календаря
let customCalendar;

function initCustomCalendar() {
    customCalendar = new CustomCalendar();
    
    // Заменяем нативный datepicker на кастомный
    const dateDisplay = document.getElementById('history-current-date');
    const nativeDatePicker = document.getElementById('history-date-picker');
    
    if (dateDisplay) {
        // Скрываем нативный календарь
        if (nativeDatePicker) {
            nativeDatePicker.style.opacity = '0';
            nativeDatePicker.style.position = 'absolute';
            nativeDatePicker.style.pointerEvents = 'none';
        }
        
        dateDisplay.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const currentDate = historyCurrentDate;
            customCalendar.show(currentDate, (selectedDate) => {
                historyCurrentDate = selectedDate;
                updateDateDisplay();
                renderHistory();
            });
        });
    }
}

// Обновляем функцию отображения даты - БЕЗ счетчика записей
function updateDateDisplay() {
    const dateDisplay = document.getElementById('history-current-date');
    if (!dateDisplay) return;

    const options = { day: 'numeric', month: 'long', year: 'numeric' };
    let dateText = historyCurrentDate.toLocaleDateString('ru-RU', options);
    dateText = dateText.replace(/\./g, ' ');
    
    // Убираем счетчик записей - оставляем только дату
    dateDisplay.textContent = dateText;
    dateDisplay.title = historyCurrentDate.toLocaleDateString('ru-RU', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });

    // Отключаем кнопку "вперед", если достигнут сегодняшний день
    const today = new Date();
    const isToday = historyCurrentDate.toDateString() === today.toDateString();
    document.getElementById('history-next-day').disabled = isToday;
}

// Инициализируем кастомный календарь при загрузке
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(initCustomCalendar, 100);
});

// Обновляем отображение даты при изменении истории
const originalRenderHistory = window.renderHistory;
window.renderHistory = function() {
    if (originalRenderHistory) originalRenderHistory();
    updateDateDisplay();
};
</script>
</main></div><script>
document.addEventListener('DOMContentLoaded', () => {
  // === ПЕЧАТЬ: История ===
  const printHistoryBtn = document.getElementById('print-history-btn');
  if (printHistoryBtn && window.innerWidth >= 921) {
    printHistoryBtn.addEventListener('click', () => window.print());
  }

  // === ПЕЧАТЬ: GIH ===
  const printGihBtn = document.getElementById('print-gih-btn');
  if (printGihBtn && window.innerWidth >= 921) {
    printGihBtn.disabled = false;
    printGihBtn.addEventListener('click', () => {
      const today = new Date().toISOString().slice(0, 10);
      if (typeof showTab === 'function') showTab('history');
      setTimeout(() => {
        if (typeof openHistoryByDate === 'function') openHistoryByDate(today);
        setTimeout(() => window.print(), 400);
      }, 300);
    });
  }
});
</script>
<script>
                (function(){
  const sections = [
    'accises','sroki','gih','dispatchers','emptied','settings','learning','practice','history','calculator'
  ];
  function hideAll(){
    sections.forEach(name=>{
      const el=document.getElementById(name+'-section');
      if(el){
        el.style.display='none';
        el.classList.add('hidden');
        el.classList.remove('show');
      }
    });
  }
  window.showTab=function(tab){
    hideAll();
    const t=document.getElementById(tab+'-section');
    if(t){
      t.style.display='block';
      t.classList.remove('hidden');
      t.classList.add('show');
    }
    document.querySelectorAll('[data-tab]').forEach(n=>{
      n.classList.toggle('active',n.dataset.tab===tab);
    });
    localStorage.setItem('active-tab',tab);
  };
  document.addEventListener('click',e=>{
    const t=e.target.closest('[data-tab]');
    if(t){ e.preventDefault(); showTab(t.dataset.tab); }
  });
  document.addEventListener('DOMContentLoaded',()=>{
    const s=localStorage.getItem('active-tab')||'accises';
    showTab(s);
  });
})();
</script>
<script>
// ====== ДЕПАТЧЕРЫ: Полный исправленный код ======
(function() {
    'use strict';
    
    // Устанавливаем путь к worker'у PDF.js
    if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    }
    
    // Список всех существующих номеров комнат
    let allRoomNumbers = [];
    
    // Состояния номеров в результатах: 0 - нет пометки, 1 - исключен, 2 - на заезд
    let resultRoomStates = new Map();
    
    // Глобальный Set для выделенных номеров
    window.selectedRooms = new Set();
    
    function getAllRoomNumbers() {
        if (typeof appData !== 'undefined' && appData.roomsList && appData.roomsList.length > 0) {
            return appData.roomsList.map(r => String(r));
        }
        // Fallback список
        return [
            '500', '502', '504', '506', '508', '509', '510', '512', '514', '516', '518', '520', '522', '524', '526', '528', '530', '532', '534',
            '600', '602', '604', '606', '608', '609', '610', '612', '614', '616', '618', '620', '622', '624', '626', '628', '630', '632', '634',
            '700', '702', '704', '706', '708', '709', '710', '712', '714', '716', '717', '718', '720', '722', '724', '725', '726', '728', '730', '732', '734',
            '800', '802', '804', '806', '808', '809', '810', '812', '814', '816', '817', '818', '820', '822', '824', '825', '826', '828', '830', '832', '834',
            '900', '902', '904', '906', '908', '909', '910', '912', '914', '916', '917', '918', '920', '922', '924', '925', '926', '928', '930', '932', '934',
            '1000', '1002', '1004', '1006', '1008', '1009', '1010', '1012', '1014', '1016', '1017', '1018', '1020', '1022', '1024', '1025', '1026', '1028', '1030', '1032', '1034',
            '1100', '1102', '1104', '1106', '1108', '1109', '1110', '1112', '1114', '1116', '1117', '1118', '1120', '1122', '1124', '1125', '1126', '1128', '1130', '1132', '1134',
            '1200', '1202', '1204', '1206', '1208', '1209', '1210', '1212', '1214', '1216', '1217', '1218', '1220', '1222', '1224', '1225', '1226', '1228', '1230', '1232', '1234',
            '1300', '1302', '1304', '1306', '1308', '1309', '1310', '1312', '1314', '1316', '1317', '1318', '1320', '1322', '1324', '1325', '1326', '1328', '1330', '1332', '1334',
            '1400', '1402', '1404', '1406', '1408', '1409', '1410', '1412', '1414', '1416', '1417', '1418', '1420', '1422', '1424', '1425', '1426', '1428', '1430', '1432', '1434',
            '1500', '1502', '1504', '1506', '1508', '1509', '1510', '1512', '1514', '1516', '1517', '1518', '1520', '1522', '1524', '1525', '1526', '1528', '1530', '1532', '1534',
            '1600', '1602', '1604', '1606', '1608', '1609', '1610', '1612', '1614', '1616', '1617', '1618', '1620', '1622', '1624', '1625', '1626', '1628', '1630', '1632', '1634',
            '1700', '1702', '1704', '1706', '1708', '1709', '1710', '1712', '1714', '1716', '1717', '1718', '1720', '1722', '1724', '1725', '1726', '1728', '1730', '1732', '1734',
            '1800', '1802', '1804', '1806', '1807', '1808', '1810', '1811', '1812', '1814', '1816', '1818', '1902', '1904', '1906', '1908', '1910', '1911', '1912', '1914', '1916', '1918', '1919', '1920'
        ];
    }

    function groupRoomsByFloor(rooms) {
        const floors = {};
        rooms.forEach(room => {
            let floor;
            if (room.length === 3) {
                floor = room.charAt(0);
            } else {
                floor = room.substring(0, 2);
            }
            if (!floors[floor]) {
                floors[floor] = [];
            }
            floors[floor].push(room);
        });
        return floors;
    }
    
    // Функция для обновления выделения номеров в DOM
    function updateRoomsSelectionInDOM() {
        // Обновляем выделение в таблице номеров (мобильная версия)
        document.querySelectorAll('.dispatchers-room-item').forEach(item => {
            const roomNumber = item.dataset.room;
            if (window.selectedRooms.has(roomNumber)) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        });
        
        updateDispatchersSelectedCount();
    }
    
    function initializeRoomGrid() {
        const grid = document.getElementById('dispatchers-roomsGrid');
        if (!grid) {
            console.error('Элемент dispatchers-roomsGrid не найден');
            return;
        }
        
        console.log('Инициализация таблицы номеров...');
        grid.innerHTML = '';
        
        allRoomNumbers = getAllRoomNumbers();
        console.log('Загружено номеров:', allRoomNumbers.length);
        
        const floors = groupRoomsByFloor(allRoomNumbers);
        const sortedFloors = Object.keys(floors).sort((a, b) => parseInt(a) - parseInt(b));
        
        if (sortedFloors.length === 0) {
            grid.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">Номера комнат не найдены</div>';
            return;
        }
        
        sortedFloors.forEach(floor => {
            const floorSection = document.createElement('div');
            floorSection.className = 'dispatchers-floor-section';
            
            const floorTitle = document.createElement('div');
            floorTitle.className = 'dispatchers-floor-title';
            floorTitle.textContent = `${floor} этаж`;
            floorSection.appendChild(floorTitle);
            
            const roomList = document.createElement('div');
            roomList.className = 'dispatchers-room-list';
            
            const sortedRooms = floors[floor].sort((a, b) => parseInt(a) - parseInt(b));
            
            sortedRooms.forEach(room => {
                const roomElement = document.createElement('div');
                roomElement.className = 'dispatchers-room-item';
                roomElement.textContent = room;
                roomElement.dataset.room = room;
                
                // Устанавливаем начальное состояние выделения
                if (window.selectedRooms.has(room)) {
                    roomElement.classList.add('selected');
                }
                
                roomList.appendChild(roomElement);
            });
            
            floorSection.appendChild(roomList);
            grid.appendChild(floorSection);
        });
        
        console.log('Таблица номеров инициализирована');
        updateDispatchersSelectedCount();
        
        // Используем делегирование событий для обработки кликов
        setupRoomGridEventDelegation();
    }
    
    function setupRoomGridEventDelegation() {
        const grid = document.getElementById('dispatchers-roomsGrid');
        if (!grid) return;
        
        // Удаляем старые обработчики и добавляем новый через делегирование
        grid.removeEventListener('click', handleRoomGridClick);
        grid.addEventListener('click', handleRoomGridClick);
    }
    
    function handleRoomGridClick(event) {
                const roomElement = event.target.closest('.dispatchers-room-item');
        if (roomElement) {
            const roomNumber = roomElement.dataset.room;
            toggleRoomSelection(roomNumber);
        }
    }
    
    // Основная функция переключения выделения номера
    function toggleRoomSelection(roomNumber) {
        if (window.selectedRooms.has(roomNumber)) {
            window.selectedRooms.delete(roomNumber);
        } else {
            window.selectedRooms.add(roomNumber);
        }
        
        // Немедленно обновляем DOM
        updateRoomsSelectionInDOM();
        
        // Сохраняем в Firebase
        saveDispatchersSelectionToFirebase();
    }
    
    function toggleResultState(roomNumber) {
        let currentState = resultRoomStates.get(roomNumber) || 0;
        currentState = (currentState + 1) % 3;
        resultRoomStates.set(roomNumber, currentState);
        updateResultRoomAppearance(roomNumber);
    }
    
    function updateResultRoomAppearance(roomNumber) {
        const roomElement = document.querySelector(`.result-room[data-room="${roomNumber}"]`);
        if (roomElement) {
            // Убираем все состояния только в блоке результатов
            roomElement.classList.remove('excluded', 'on-arrival');
            const state = resultRoomStates.get(roomNumber) || 0;
            if (state === 1) {
                roomElement.classList.add('excluded');
            } else if (state === 2) {
                roomElement.classList.add('on-arrival');
            }
        }
    }
    
    function updateDispatchersSelectedCount() {
        const countEl = document.getElementById('dispatchers-selectedCount');
        if (countEl) {
            const loadedCount = window.todayLoadedRooms ? window.todayLoadedRooms.size : 0;
            countEl.textContent = `Загружено: ${loadedCount} номеров`;
        }
    }
    
    // Функция для парсинга номеров комнат из текста чата
    function parseRoomNumbersFromChatText(text) {
        const validRooms = new Set(appData.roomsList.map(room => parseInt(room)));
        const foundRooms = new Set();
        
        const lines = text.split('\n').filter(line => line.trim());
        
        lines.forEach(line => {
            const cleanLine = line.replace(/\[\d{2}\.\d{2}, \d{2}:\d{2}\]\s*[^:]*:\s*/, '');
            
            const numbers = cleanLine.match(/\d+/g);
            
            if (numbers) {
                numbers.forEach(numStr => {
                    const num = parseInt(numStr, 10);
                    if (validRooms.has(num)) {
                        foundRooms.add(num);
                    }
                });
            }
        });
        
        return Array.from(foundRooms);
    }

    // Функция для парсинга номеров из ручного ввода (без диапазонов)
    function parseRoomNumbersFromManualInput(text) {
        const validRooms = new Set(appData.roomsList.map(room => parseInt(room)));
        const foundRooms = new Set();
        
        const parts = text.split(/[,;\s\n]+/).filter(part => part.trim());
        
        parts.forEach(part => {
            part = part.trim();
            
            const num = parseInt(part);
            if (!isNaN(num) && validRooms.has(num)) {
                foundRooms.add(num);
            }
        });
        
        return Array.from(foundRooms);
    }

    // Умная функция парсинга, которая определяет тип ввода
    function parseRoomNumbersFromText(text) {
        if (text.includes('[') && text.includes(']') && text.includes(':')) {
            return parseRoomNumbersFromChatText(text);
        } else {
            return parseRoomNumbersFromManualInput(text);
        }
    }

    // Функция для очистки всех выделенных номеров
    function clearAllSelectedRooms() {
        window.selectedRooms.clear();
        updateRoomsSelectionInDOM();
        saveDispatchersSelectionToFirebase();
    }

    // Функция для добавления номеров к текущим выделениям
    function addToSelectedRooms(roomNumbers) {
        roomNumbers.forEach(roomNumber => {
            window.selectedRooms.add(String(roomNumber));
        });
        
        updateRoomsSelectionInDOM();
        saveDispatchersSelectionToFirebase();
    }

    // УЛУЧШЕННАЯ функция для сохранения выделенных номеров в Firebase
    function saveDispatchersSelectionToFirebase() {
        const selectedRoomsArray = Array.from(window.selectedRooms).map(Number);
        
        // Сохраняем в appData для синхронизации
        appData.dispatchersSelectedRooms = selectedRoomsArray;
        
        // Сохраняем в Firebase
        database.ref('minibarData/dispatchersSelectedRooms').set(selectedRoomsArray)
            .catch(error => {
                console.error('Ошибка сохранения выделенных номеров в Firebase:', error);
            });
    }

    // УЛУЧШЕННАЯ функция для загрузки выделенных номеров из Firebase
    function loadDispatchersSelectionFromFirebase() {
        database.ref('minibarData/dispatchersSelectedRooms').once('value')
            .then(snapshot => {
                const selectedRoomsFromDb = snapshot.val() || [];
                
                // Очищаем текущее выделение
                window.selectedRooms.clear();
                
                // Загружаем данные из Firebase
                selectedRoomsFromDb.forEach(roomNum => {
                    window.selectedRooms.add(String(roomNum));
                });
                
                // Обновляем DOM
                updateRoomsSelectionInDOM();
            })
            .catch(error => {
                console.error('Ошибка загрузки выделенных номеров из Firebase:', error);
            });
    }

    // УЛУЧШЕННЫЙ слушатель изменений выделенных номеров в реальном времени
    function setupDispatchersRealtimeListener() {
        database.ref('minibarData/dispatchersSelectedRooms').on('value', snapshot => {
            const selectedRoomsFromDb = snapshot.val() || [];
            
            // Очищаем текущее выделение
            window.selectedRooms.clear();
            
            // Загружаем данные из Firebase
            selectedRoomsFromDb.forEach(roomNum => {
                window.selectedRooms.add(String(roomNum));
            });
            
            // Обновляем DOM
            updateRoomsSelectionInDOM();
        });
    }

    function initDispatchersEventHandlers() {
        // Обработчики для десктопной версии
        const applyRoomsBtn = document.getElementById('dispatchers-apply-rooms');
        const clearRoomsBtn = document.getElementById('dispatchers-clear-rooms');
        const roomInput = document.getElementById('dispatchers-room-input');
        
        // Обработчики для мобильной версии
        const applyRoomsBtnMobile = document.getElementById('dispatchers-apply-rooms-mobile');
        const clearRoomsBtnMobile = document.getElementById('dispatchers-clear-rooms-mobile');
        const roomInputMobile = document.getElementById('dispatchers-room-input-mobile');
        
        // Общая функция для обработки ввода данных
        function handleApplyRooms(inputElement) {
            const text = inputElement.value.trim();
            if (!text) return;
            
            const roomNumbers = parseRoomNumbersFromText(text);
            
            if (roomNumbers.length === 0) {
                inputElement.value = '';
                return;
            }
            
            // Добавляем номера к текущим выделениям (не сбрасываем предыдущие)
            addToSelectedRooms(roomNumbers);
            
            // Очищаем поле ввода
            inputElement.value = '';
        }
        
        // Обработчики для десктопной версии
        if (applyRoomsBtn && roomInput) {
            applyRoomsBtn.addEventListener('click', () => handleApplyRooms(roomInput));
            
            // Обработка Enter в поле ввода
            roomInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleApplyRooms(roomInput);
                }
            });
        }
        
        if (clearRoomsBtn) {
            clearRoomsBtn.addEventListener('click', clearAllSelectedRooms);
        }
        
        // Обработчики для мобильной версии
        if (applyRoomsBtnMobile && roomInputMobile) {
            applyRoomsBtnMobile.addEventListener('click', () => handleApplyRooms(roomInputMobile));
            
            // Обработка Enter в поле ввода
            roomInputMobile.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleApplyRooms(roomInputMobile);
                }
            });
        }
        
        if (clearRoomsBtnMobile) {
            clearRoomsBtnMobile.addEventListener('click', clearAllSelectedRooms);
        }
    }

    // PDF обработка функций
    async function processPDFWithExclusion() {
        const fileInput = document.getElementById('dispatchers-pdfFile');
        const resultDiv = document.getElementById('dispatchers-result');
        
        if (!fileInput || !fileInput.files[0]) {
            showError('Пожалуйста, выберите PDF файл');
            return;
        }

        if (resultDiv) {
            resultDiv.innerHTML = '<p class="dispatchers-loading">Обработка PDF файла с исключением выбранных номеров...</p>';
        }

        try {
            const file = fileInput.files[0];
            const arrayBuffer = await file.arrayBuffer();
            await processPDFArrayBufferWithExclusion(arrayBuffer);
        } catch (error) {
            console.error('Ошибка при обработке PDF:', error);
            showError('Ошибка при обработке PDF файла: ' + error.message);
        }
    }
    
    async function processPDFArrayBufferWithExclusion(arrayBuffer) {
        const resultDiv = document.getElementById('dispatchers-result');
        
        if (typeof pdfjsLib === 'undefined') {
            showError('PDF.js не загружен. Пожалуйста, обновите страницу.');
            return;
        }
        
        try {
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            
            let allText = '';
            const foundRoomNumbers = new Set();

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                
                let pageText = '';
                const textItems = [];
                
                for (const item of textContent.items) {
                    pageText += item.str + ' ';
                    textItems.push({
                        text: item.str,
                        x: item.transform[4],
                        y: item.transform[5]
                    });
                }
                
                allText += pageText;
                analyzeTableStructure(textItems, foundRoomNumbers);
            }

            analyzeSimpleText(allText, foundRoomNumbers);

            if (foundRoomNumbers.size === 0) {
                showError('Номера комнат не найдены в файле. Проверьте структуру PDF.');
                return;
            }

            // Сохраняем найденные в PDF номера глобально
            window.foundRoomsFromPdf = new Set(foundRoomNumbers);

            // Перестраиваем итоговый список с учётом текущих "уже проверено" и выделений
            recomputeAndShowResults();
            
        } catch (error) {
            console.error('Ошибка при обработке PDF:', error);
            showError('Ошибка при обработке PDF файла: ' + error.message);
        }
    }

    function analyzeTableStructure(textItems, foundRoomNumbers) {
        const lines = {};
        textItems.forEach(item => {
            const y = Math.round(item.y);
            if (!lines[y]) lines[y] = [];
            lines[y].push(item);
        });

        const sortedLines = Object.keys(lines).sort((a, b) => b - a);
        
        sortedLines.forEach(y => {
            const lineItems = lines[y];
            lineItems.sort((a, b) => a.x - b.x);
            
            const lineText = lineItems.map(item => item.text).join(' ');
            
            const roomMatch = lineText.match(/^(\d{3,4})\s/);
            if (roomMatch) {
                const roomNumber = roomMatch[1];
                validateAndAddRoomNumber(roomNumber, foundRoomNumbers);
            }
            
            const patternMatch = lineText.match(/\b(\d{3,4})\s+[A-Z][a-z]/);
            if (patternMatch) {
                const roomNumber = patternMatch[1];
                validateAndAddRoomNumber(roomNumber, foundRoomNumbers);
            }
        });
    }

    function analyzeSimpleText(allText, foundRoomNumbers) {
        const lines = allText.split(/\r?\n/);
        
        lines.forEach(line => {
            line = line.trim();
            
            const patterns = [
                /^(\d{3,4})\s+[A-Z]/,
                /\b(\d{3,4})\s+[A-Z][a-z]+,/,
                /Room No\.\s*[\s\S]*?(\d{3,4})\b/,
                /Departure[\s\S]*?(\d{3,4})\s/
            ];
            
            patterns.forEach(pattern => {
                const match = line.match(pattern);
                if (match && match[1]) {
                    validateAndAddRoomNumber(match[1], foundRoomNumbers);
                }
            });
            
            const numberMatches = line.match(/\b\d{3,4}\b/g);
            if (numberMatches) {
                numberMatches.forEach(match => {
                    if (!line.match(/\d{1,2}\.\d{1,2}\.\d{2,4}/) &&
                        !line.match(/\d{1,2}:\d{2}/) &&
                        isValidRoomNumberFormat(match)) {
                        validateAndAddRoomNumber(match, foundRoomNumbers);
                    }
                });
            }
        });
    }

    function validateAndAddRoomNumber(roomNumber, foundRoomNumbers) {
        const normalized = roomNumber.replace(/^0+/, '');
        
        if (allRoomNumbers.includes(normalized)) {
            foundRoomNumbers.add(normalized);
        }
    }

    function isValidRoomNumberFormat(number) {
        const num = parseInt(number);
        return num >= 1 && num <= 1999;
    }

    function showError(message) {
        const resultDiv = document.getElementById('dispatchers-result');
        if (resultDiv) {
            resultDiv.innerHTML = `<div class="dispatchers-error">${message}</div>`;
        }
    }

    function updateFoundRoomsAppearance(foundRooms) {
        document.querySelectorAll('.dispatchers-room-item.found').forEach(item => {
            item.classList.remove('found');
        });
        
        foundRooms.forEach(room => {
            const roomElement = document.querySelector(`.dispatchers-room-item[data-room="${room}"]`);
            if (roomElement) {
                roomElement.classList.add('found');
            }
        });
    }

    function showResults(rooms, totalFound) {
        const resultDiv = document.getElementById('dispatchers-result');
        if (!resultDiv) return;
        
        const selectedRoomsSet = new Set(Array.from(window.selectedRooms || []).map(String));
        const excludedStateCount = Math.max(0, totalFound - rooms.length);
        const effectiveRoomsCount = rooms.length;
        const resultFloors = groupRoomsByFloor(rooms);
        const sortedFloors = Object.keys(resultFloors).sort((a, b) => parseInt(a) - parseInt(b));
        
        let resultsHTML = `
            <div class="dispatchers-stats">
                <div class="dispatchers-stat-item">
                    <div class="dispatchers-stat-value">${effectiveRoomsCount}</div>
                    <div class="dispatchers-stat-label">Итоговых номеров</div>
                </div>
                <div class="dispatchers-stat-item">
                    <div class="dispatchers-stat-value">${excludedStateCount}</div>
                    <div class="dispatchers-stat-label">Исключено номеров</div>
                </div>
            </div>
            
            <div style="font-weight:600; font-size:14px; margin-bottom:10px;">Итоговые номера (${rooms.length}):</div>
            <p class="muted" style="font-size:12px; margin-bottom:15px;"><em>один клик - исключить жилой номер, двойной клик - пометить номер на заезд</em></p>
        `;
        
        sortedFloors.forEach(floor => {
            resultsHTML += `<div class="dispatchers-floor-section">
                <div class="dispatchers-floor-title">${floor} этаж</div>
                <div class="dispatchers-room-list">`;
            
            const sortedRooms = resultFloors[floor].sort((a, b) => parseInt(a) - parseInt(b));
            sortedRooms.forEach(room => {
                const state = resultRoomStates.get(room) || 0;
                if (selectedRoomsSet.has(String(room))) {
                    return;
                }

                // Восстанавливаем визуальное состояние по resultRoomStates
                let classes = 'dispatchers-room-item result-room';
                if (state === 1) {
                    classes += ' excluded';
                } else if (state === 2) {
                    classes += ' on-arrival';
                }

                resultsHTML += `<div class="${classes}" data-room="${room}">${room}</div>`;
            });
            
            resultsHTML += `</div></div>`;
        });
        
        resultsHTML += `
            <div style="margin-top: 20px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                <button class="btn" onclick="window.dispatchersPrintDepartures()"><i class="fas fa-print"></i> Выгрузить депатчеры</button>
                
                <label class="toggle-switch">
                    <input type="checkbox" id="split-between-two">
                    <div class="toggle-slider">
                        <div class="toggle-knob"></div>
                    </div>
                    <span>Разделить на двоих</span>
                </label>
                <label class="toggle-switch">
  <input type="checkbox" id="dispatchers-include-deadlines">
  <div class="toggle-slider">
                        <div class="toggle-knob"></div>
                    </div>
  <span>Выписать сроки</span>
</label>
                
            </div>
        `;
        
        resultDiv.innerHTML = resultsHTML;
        
        // Используем делегирование событий для результатов
        setupResultsEventDelegation();
    }

    // Пересчитать и показать итоговый список, исходя из:
    // - найденных в PDF номеров (window.foundRoomsFromPdf)
    // - выбранных номеров (window.selectedRooms)
    // - уже проверенных номеров из беседы (window.todayLoadedRooms)
    function recomputeAndShowResults() {
        const foundSet = window.foundRoomsFromPdf;
        if (!foundSet || foundSet.size === 0) {
            return;
        }

        // Сохраняем текущее состояние переключателей перед перерисовкой
        const splitCheckboxExisting = document.getElementById('split-between-two');
        const includeDeadlinesExisting = document.getElementById('dispatchers-include-deadlines');
        const splitWasChecked = splitCheckboxExisting ? splitCheckboxExisting.checked : false;
        const includeDeadlinesWasChecked = includeDeadlinesExisting ? includeDeadlinesExisting.checked : false;

        const allFound = Array.from(foundSet);

        const filteredRooms = allFound.filter(room => {
            const roomStr = String(room);
            return !window.selectedRooms.has(roomStr) &&
                   !(window.todayLoadedRooms && window.todayLoadedRooms.has(roomStr));
        });

        const sortedRooms = filteredRooms.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));

        // Обновляем подсветку "found" в сетке номеров
        updateFoundRoomsAppearance(foundSet);

        // Перерисовываем итоговый блок
        showResults(sortedRooms, foundSet.size);

        // Восстанавливаем состояние переключателей после перерисовки
        const splitCheckboxNew = document.getElementById('split-between-two');
        if (splitCheckboxNew) {
            splitCheckboxNew.checked = splitWasChecked;
        }
        const includeDeadlinesNew = document.getElementById('dispatchers-include-deadlines');
        if (includeDeadlinesNew) {
            includeDeadlinesNew.checked = includeDeadlinesWasChecked;
        }
    }

    function setupResultsEventDelegation() {
        const resultDiv = document.getElementById('dispatchers-result');
        if (!resultDiv) return;
        
        // Удаляем старые обработчики и добавляем новый через делегирование
        resultDiv.removeEventListener('click', handleResultsClick);
        resultDiv.addEventListener('click', handleResultsClick);
    }

    function handleResultsClick(event) {
        const roomElement = event.target.closest('.result-room');
        if (roomElement) {
            const roomNumber = roomElement.dataset.room;
            toggleResultState(roomNumber);
        }
    }

    function formatDeadlineProductsForRoomNumber(roomNumber) {
    // находим запись комнаты в appData.rooms (если есть)
    const room = (appData.rooms || []).find(r => r && String(r.number) === String(roomNumber));
    if (!room) return 'check'; // нет записи — ничего не пишем (или можно "Проверить сроки" по желанию)
    if (room.deadlinesStatus === DEADLINE_STATUS.OK) return ''; // сроки в порядке — ничего не дописываем
    // собираем выбранные продукты
    const entries = Object.entries(room.products || {}).filter(([, cnt]) => Number(cnt) > 0);
    if (entries.length === 0) return 'check';
    // формат: Назв. xN, Назв2 xM
    return entries.map(([k, cnt]) => {
        const name = appData.products && (appData.products[k] || k) || k;
        return Number(cnt) > 1 ? `${name} x${cnt}` : name;
    }).join(', ');
}

function aggregateDeadlineProductsForRoomNumbers(roomNumbers) {
    // суммарные количества по списку номеров
    const tot = {};
    (roomNumbers || []).forEach(rn => {
        const room = (appData.rooms || []).find(r => r && String(r.number) === String(rn));
        if (!room || room.deadlinesStatus === DEADLINE_STATUS.OK) return; // пропускаем OK
        Object.entries(room.products || {}).forEach(([k, cnt]) => {
            const n = Number(cnt) || 0;
            if (n > 0) tot[k] = (tot[k] || 0) + n;
        });
    });
    const entries = Object.entries(tot).sort((a, b) => b[1] - a[1]);
    if (entries.length === 0) return '';
    return entries.map(([k, cnt]) => {
        const name = appData.products && (appData.products[k] || k) || k;
        return `${name} x${cnt}`;
    }).join(', ');
}

function printDepartures() {
    const now = new Date();
    const dateString = now.toLocaleDateString('ru-RU');

    const splitBetweenTwo =
        document.getElementById('split-between-two') &&
        document.getElementById('split-between-two').checked;

    const includeDeadlines =
        document.getElementById('dispatchers-include-deadlines') &&
        document.getElementById('dispatchers-include-deadlines').checked;

    // Собираем все номера, кроме тех, что исключены
    const finalRooms = [];
    document.querySelectorAll('.result-room').forEach(roomEl => {
        const roomNumber = roomEl.dataset.room;
        const state = resultRoomStates.get(roomNumber) || 0;
        if (state !== 1) {
            const displayNumber = state === 2 ? `→ ${roomNumber}` : roomNumber;
            // Информацию об "опустошённости" будем подставлять позже,
            // из загруженных номеров беседы (todayRoomsData)
            finalRooms.push({ number: roomNumber, display: displayNumber });
        }
    });

    // Сортируем по числовому значению номера
    finalRooms.sort((a, b) => parseInt(a.number, 10) - parseInt(b.number, 10));

    // Вспомогательная функция для подписей из вкладки "Сроки"
    function buildDeadlineSubForRoom(roomNumber) {
        const room = (appData.rooms || []).find(
            r => r && String(r.number) === String(roomNumber)
        );

        // нет данных — просим проверить
        if (!room) return 'check';
        // если "Сроки в порядке" — ничего не пишем
        if (room.deadlinesStatus === DEADLINE_STATUS.OK) return '';
        // если выбраны продукты — показываем их
        const entries = Object.entries(room.products || {}).filter(
            ([, c]) => Number(c) > 0
        );
        if (entries.length === 0) return 'check';
        return entries
            .map(([k, c]) => {
                const name = (appData.products && (appData.products[k] || k)) || k;
                return Number(c) > 1 ? `${name} x${c}` : name;
            })
            .join(', ');
    }

    // Разбиваем на страницы
    let pages = [];
    if (splitBetweenTwo) {
        const half = Math.ceil(finalRooms.length / 2);
        const leftColumn = finalRooms.slice(0, half);
        const rightColumn = finalRooms.slice(half);

        const itemsPerPage = 36;
        const maxPages = Math.ceil(
            Math.max(leftColumn.length, rightColumn.length) / itemsPerPage
        );

        for (let pageNum = 0; pageNum < maxPages; pageNum++) {
            const pageLeft = leftColumn.slice(
                pageNum * itemsPerPage,
                (pageNum + 1) * itemsPerPage
            );
            const pageRight = rightColumn.slice(
                pageNum * itemsPerPage,
                (pageNum + 1) * itemsPerPage
            );
            while (pageLeft.length < itemsPerPage) pageLeft.push(null);
            while (pageRight.length < itemsPerPage) pageRight.push(null);
            pages.push([pageLeft, pageRight]);
        }
    } else {
        const itemsPerPage = 72;
        const pageCount = Math.ceil(finalRooms.length / itemsPerPage);
        for (let pageNum = 0; pageNum < pageCount; pageNum++) {
            const pageStart = pageNum * itemsPerPage;
            const pageEnd = pageStart + itemsPerPage;
            const pageItems = finalRooms.slice(pageStart, pageEnd);

            const left = pageItems.slice(0, 36);
            const right = pageItems.slice(36, 72);

            while (left.length < 36) left.push(null);
            while (right.length < 36) right.push(null);

            pages.push([left, right]);
        }
    }

    // Создаем окно печати
    const printWindow = window.open('', '_blank');
    let htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Departures ${dateString}</title>
            <style>
                @page { size: A4 landscape; margin: 1cm; }
                body { font-family: Times New Roman, serif; margin: 0; padding: 0; }
                .page-container { display:flex; justify-content:space-around; width:100%; height:95vh; page-break-after:always; }
                .page-column { flex:1; padding-top:1cm; padding-left:1cm; padding-right:1cm; box-sizing:border-box; }
                .print-table { width:100%; border-collapse:collapse; font-size:10px; }
                .print-table th, .print-table td { border:1px solid #000; padding:0px; height:16px; vertical-align:middle; }
                .print-table th { background:#f0f0f0; font-weight:bold; text-align:center; }
                .print-table .number-col { width:50px; text-align:center; }
                .print-table .departures-col { width:auto; text-align:left; padding-left:6px; }
                .subtext { display:block; font-size:10px; color:#111; margin-top:2px; }
            </style>
        </head>
        <body>
    `;

    // Рисуем все страницы
    pages.forEach((page, pageIndex) => {
            let left = page[0];
            let right = page[1];

        if (splitBetweenTwo && pageIndex % 2 === 1) {
            [left, right] = [right, left];}
        htmlContent += `
            <div class="page-container">
                <div class="page-column">
                    <table class="print-table">
                        <thead>
                            <tr>
                                <th class="number-col"><font size="2">№</font></th>
                                <th class="departures-col" style="text-align: center;"><font size="2">Departures of ${dateString}</font></th>
                            </tr>
                        </thead>
                        <tbody>
        `;

        for (let i = 0; i < 36; i++) {
            const item = left[i];
            if (item) {
                let sub = '';

                // Проверяем, был ли номер помечен как опустошённый в todayRoomsData
                let isEmptied = false;
                if (window.todayRoomsData && Array.isArray(window.todayRoomsData)) {
                    const info = window.todayRoomsData.find(r => String(r.room) === String(item.number));
                    if (info && info.emptied) {
                        isEmptied = true;
                    }
                }

                // Дополнительно учитываем глобальный список опустошённых номеров
                if (!isEmptied && window.emptiedRoomsGlobal instanceof Set) {
                    if (window.emptiedRoomsGlobal.has(String(item.number))) {
                        isEmptied = true;
                    }
                }

                if (includeDeadlines && !isEmptied) {
                    const one = buildDeadlineSubForRoom(item.number);
                    sub = one || '';
                }

                // Если номер опустошён — во второй колонке пишем "пустой"
                const cellText = isEmptied
                    ? '<span class="subtext">пустой</span>'
                    : (sub ? `<span class="subtext">${escapeHtml(sub)}</span>` : '&nbsp;');

                htmlContent += `
                    <tr>
                        <td class="number-col"><strong><font size="2">${item.display}</font></strong></td>
                        <td class="departures-col">
                            ${cellText}
                        </td>
                    </tr>
                `;
            } else {
                htmlContent += `
                    <tr>
                        <td class="number-col">&nbsp;</td>
                        <td class="departures-col">&nbsp;</td>
                    </tr>
                `;
            }
        }

        htmlContent += `
                        </tbody>
                    </table>
                </div>
                <div class="page-column">
                    <table class="print-table">
                        <thead>
                            <tr>
                                <th class="number-col"><font size="2">№</font></th>
                                <th class="departures-col" style="text-align: center;"><font size="2">Departures of ${dateString}</font></th>
                            </tr>
                        </thead>
                        <tbody>
        `;

        for (let i = 0; i < 36; i++) {
            const item = right[i];
            if (item) {
                let sub = '';

                // Проверяем, был ли номер помечен как опустошённый в todayRoomsData
                let isEmptied = false;
                if (window.todayRoomsData && Array.isArray(window.todayRoomsData)) {
                    const info = window.todayRoomsData.find(r => String(r.room) === String(item.number));
                    if (info && info.emptied) {
                        isEmptied = true;
                    }
                }

                // Дополнительно учитываем глобальный список опустошённых номеров
                if (!isEmptied && window.emptiedRoomsGlobal instanceof Set) {
                    if (window.emptiedRoomsGlobal.has(String(item.number))) {
                        isEmptied = true;
                    }
                }

                if (includeDeadlines && !isEmptied) {
                    const one = buildDeadlineSubForRoom(item.number);
                    sub = one || '';
                }

                // Если номер опустошён — во второй колонке пишем "пустой"
                const cellText = isEmptied
                    ? '<span class="subtext">пустой</span>'
                    : (sub ? `<span class="subtext">${escapeHtml(sub)}</span>` : '&nbsp;');

                htmlContent += `
                    <tr>
                        <td class="number-col"><strong><font size="2">${item.display}</font></strong></td>
                        <td class="departures-col">
                            ${cellText}
                        </td>
                    </tr>
                `;
            } else {
                htmlContent += `
                    <tr>
                        <td class="number-col">&nbsp;</td>
                        <td class="departures-col">&nbsp;</td>
                    </tr>
                `;
            }
        }

        htmlContent += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    });

    htmlContent += `
        </body>
        </html>
    `;

    printWindow.document.write(htmlContent);
    printWindow.document.close();

    printWindow.onload = function() {
        setTimeout(() => {
            printWindow.print();
            setTimeout(() => {
                printWindow.close();
            }, 500);
        }, 300);
    };
}

// Защита от вставки HTML
function escapeHtml(str) {
    if (!str && str !== 0) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}


    function clearResults() {
        const resultDiv = document.getElementById('dispatchers-result');
        if (resultDiv) {
            resultDiv.innerHTML = '<p class="muted" style="text-align:center; padding:20px;">Результаты очищены.</p>';
        }
        
        const fileInput = document.getElementById('dispatchers-pdfFile');
        const fileNameSpan = document.getElementById('dispatchers-fileName');
        if (fileInput) {
            fileInput.value = '';
        }
        if (fileNameSpan) {
            fileNameSpan.textContent = '';
        }
        
        document.querySelectorAll('.dispatchers-room-item.found').forEach(item => {
            item.classList.remove('found');
        });
        
        resultRoomStates.clear();
    }

    // Глобальная переменная для хранения загруженных номеров из беседы
    window.todayLoadedRooms = new Set();
    
    // Режим сортировки: 'time' или 'floor'
    let todayRoomsSortMode = localStorage.getItem('dispatchersTodayRoomsSortMode') || 'time';
    
    // Функция для группировки номеров по этажам
    function groupTodayRoomsByFloor(rooms) {
        const floors = {};
        rooms.forEach(r => {
            const room = String(r.room);
            let floor;
            if (room.length === 3) {
                floor = room.charAt(0);
            } else {
                floor = room.substring(0, 2);
            }
            if (!floors[floor]) {
                floors[floor] = [];
            }
            floors[floor].push(r);
        });
        return floors;
    }
    
    // Функция для отображения номеров в зависимости от режима сортировки
    function renderTodayRooms(rooms, roomsEl) {
        roomsEl.innerHTML = '';
        
        if (todayRoomsSortMode === 'floor') {
            // Группировка по этажам
            roomsEl.classList.add('floor-mode');
            const floors = groupTodayRoomsByFloor(rooms);
            const sortedFloors = Object.keys(floors).sort((a, b) => parseInt(a) - parseInt(b));
            
            sortedFloors.forEach(floor => {
                const floorSection = document.createElement('div');
                floorSection.className = 'dispatchers-floor-section';
                
                const floorTitle = document.createElement('div');
                floorTitle.className = 'dispatchers-floor-title';
                floorTitle.textContent = `${floor} этаж`;
                floorSection.appendChild(floorTitle);
                
                const roomList = document.createElement('div');
                roomList.className = 'dispatchers-room-list';
                
                const sortedRooms = floors[floor].sort((a, b) => parseInt(a.room) - parseInt(b.room));
                
                sortedRooms.forEach(r => {
                    const card = document.createElement('div');
                    card.className = 'dispatchers-today-room-card';
                    card.dataset.room = r.room;
                    
                    card.innerHTML = `
                        <div class="dispatchers-today-room-number">${r.room}</div>
                        <div class="dispatchers-today-room-time">${r.time}</div>
                    `;

                    // Значок опустошения (∅) в левом нижнем углу, если номер опустошён
                    if (r.emptied) {
                        const emptyMark = document.createElement('div');
                        emptyMark.className = 'dispatchers-today-room-empty';
                        emptyMark.textContent = '∅';
                        card.appendChild(emptyMark);
                    }

                    // Если номер был найден в загруженном PDF, добавляем обводку
                    if (window.foundRoomsFromPdf && window.foundRoomsFromPdf.has(String(r.room))) {
                        card.classList.add('found');
                    }

                    roomList.appendChild(card);
                });
                
                floorSection.appendChild(roomList);
                roomsEl.appendChild(floorSection);
            });
        } else {
            // Сортировка по времени
            roomsEl.classList.remove('floor-mode');

            // Создаём отсортированную копию массива по времени
            const sortedRoomsByTime = [...rooms].sort((a, b) => {
                const parseTime = (t) => {
                    if (!t) return 0;

                    // Пытаемся разобрать формат HH:MM или H:MM
                    if (typeof t === 'string') {
                        const m = t.match(/(\d{1,2}):(\d{2})/);
                        if (m) {
                            return parseInt(m[1], 10) * 60 + parseInt(m[2], 10);
                        }
                    }

                    // Пытаемся разобрать как дату/время
                    const d = new Date(t);
                    if (!isNaN(d.getTime())) {
                        return d.getTime();
                    }

                    // Если ничего не подошло — возвращаем 0
                    return 0;
                };

                return parseTime(a.time) - parseTime(b.time);
            });

            sortedRoomsByTime.forEach(r => {
                const card = document.createElement('div');
                card.className = 'dispatchers-today-room-card';
                card.dataset.room = r.room;
                
                card.innerHTML = `
                    <div class="dispatchers-today-room-number">${r.room}</div>
                    <div class="dispatchers-today-room-time">${r.time}</div>
                `;

                // Значок опустошения (∅) в левом нижнем углу, если номер опустошён
                if (r.emptied) {
                    const emptyMark = document.createElement('div');
                    emptyMark.className = 'dispatchers-today-room-empty';
                    emptyMark.textContent = '∅';
                    card.appendChild(emptyMark);
                }

                // Если номер был найден в загруженном PDF, добавляем обводку
                if (window.foundRoomsFromPdf && window.foundRoomsFromPdf.has(String(r.room))) {
                    card.classList.add('found');
                }

                roomsEl.appendChild(card);
            });
        }
    }
    
    // Функция для переключения режима сортировки
    function toggleTodayRoomsSortMode() {
    todayRoomsSortMode = todayRoomsSortMode === 'time' ? 'floor' : 'time';
    localStorage.setItem('dispatchersTodayRoomsSortMode', todayRoomsSortMode);
    
    // Обновляем метку кнопки ДЛЯ ОБЕИХ ВЕРСИЙ
    const sortLabelDesktop = document.getElementById('dispatchers-sort-label');
    const sortLabelMobile = document.getElementById('dispatchers-sort-label-mobile');
    
    if (sortLabelDesktop) {
        sortLabelDesktop.textContent = todayRoomsSortMode === 'time' ? 'По времени' : 'По этажам';
    }
    
    if (sortLabelMobile) {
        sortLabelMobile.textContent = todayRoomsSortMode === 'time' ? 'По времени' : 'По этажам';
    }
    
    // Перерисовываем номера
    const roomsEl = document.getElementById('dispatchers-today-rooms-list');
    if (roomsEl && window.todayRoomsData) {
        renderTodayRooms(window.todayRoomsData, roomsEl);
    }
}
    
    // Функция для загрузки номеров из беседы (автоматически)
    function loadTodayRooms() {
        const statusEl = document.getElementById('dispatchers-today-rooms-status');
        const roomsEl = document.getElementById('dispatchers-today-rooms-list');
        
        if (!statusEl || !roomsEl) {
            // Элементы не найдены
            return;
        }
        
        // Инициализируем кнопку сортировки для десктопной версии
        const sortToggleDesktop = document.getElementById('dispatchers-sort-toggle');
        if (sortToggleDesktop) {
            sortToggleDesktop.addEventListener('click', toggleTodayRoomsSortMode);

            // Устанавливаем начальную метку
            const sortLabelDesktop = document.getElementById('dispatchers-sort-label');
            if (sortLabelDesktop) {
                sortLabelDesktop.textContent = todayRoomsSortMode === 'time' ? 'По времени' : 'По этажам';
            }
        }

        // Инициализируем кнопку сортировки для мобильной версии
        const sortToggleMobile = document.getElementById('dispatchers-sort-toggle-mobile');
        if (sortToggleMobile) {
            sortToggleMobile.addEventListener('click', toggleTodayRoomsSortMode);

            // Устанавливаем начальную метку
            const sortLabelMobile = document.getElementById('dispatchers-sort-label-mobile');
            if (sortLabelMobile) {
                sortLabelMobile.textContent = todayRoomsSortMode === 'time' ? 'По времени' : 'По этажам';
            }
        }
        
        // Базовый URL вашего бэкенда
        const API_BASE = 'https://minibarbot.onrender.com';
        const TODAY_URL = API_BASE + '/today-rooms';
        const EMPTIED_URL = API_BASE + '/emptied-rooms';
        
        async function fetchTodayRooms() {
            try {
                const resp = await fetch(TODAY_URL);
                const data = await resp.json();
                
                if (!resp.ok) {
                    statusEl.innerHTML = '<span class="dispatchers-today-rooms-error">Ошибка сервера: ' + (data.message || data.error || resp.status) + '</span>';
                    roomsEl.innerHTML = '';
                    window.todayLoadedRooms.clear();
                    
                    // Обновляем заголовок с количеством номеров
                    const titleEl = document.getElementById('dispatchers-today-rooms-title');
                    if (titleEl) {
                        titleEl.textContent = 'Уже проверено (0):';
                    }
                    
                    updateDispatchersSelectedCount();
                    return;
                }
                
                const rooms = data.rooms || [];
                
                // Сохраняем загруженные номера в глобальную переменную
                window.todayLoadedRooms.clear();
                rooms.forEach(r => {
                    window.todayLoadedRooms.add(String(r.room));
                });
                
                // Обновляем заголовок с количеством номеров
                const titleEl = document.getElementById('dispatchers-today-rooms-title');
                if (titleEl) {
                    titleEl.textContent = `Уже проверено (${rooms.length}):`;
                }
                
                // Сохраняем данные для перерисовки при смене режима сортировки
                window.todayRoomsData = rooms;
                
                if (!rooms.length) {
                    statusEl.textContent = 'За сегодня пока нет номеров. Ждём новые сообщения...';
                    roomsEl.innerHTML = '';
                } else {
                    statusEl.textContent = '';
                    
                    // Отображаем номера в зависимости от режима сортировки
                    renderTodayRooms(rooms, roomsEl);

                    // При обновлении списка "Уже проверено" пересчитываем итоговые депатчеры,
                    // если уже есть загруженный PDF
                    if (window.foundRoomsFromPdf && window.foundRoomsFromPdf.size > 0) {
                        recomputeAndShowResults();
                    }
                }
                
                // Параллельно загружаем глобальный список опустошённых номеров
                try {
                    const emptiedResp = await fetch(EMPTIED_URL);
                    const emptiedData = await emptiedResp.json();
                    const emptiedRooms = (emptiedData && emptiedData.rooms) || [];
                    window.emptiedRoomsGlobal = new Set(
                        emptiedRooms.map(r => String(r))
                    );
                } catch (err) {
                    console.error('Failed to load emptied rooms:', err);
                    window.emptiedRoomsGlobal = window.emptiedRoomsGlobal || new Set();
                }

                // Обновляем счетчик загруженных номеров
                updateDispatchersSelectedCount();
                
            } catch (e) {
                statusEl.innerHTML = '<span class="dispatchers-today-rooms-error">Ошибка при запросе к бэкенду: ' + e.message + '</span>';
                roomsEl.innerHTML = '';
                window.todayLoadedRooms.clear();
                
                // Обновляем заголовок с количеством номеров
                const titleEl = document.getElementById('dispatchers-today-rooms-title');
                if (titleEl) {
                    titleEl.textContent = 'Уже проверено (0):';
                }
                
                updateDispatchersSelectedCount();
            }
        }
        
        // Загружаем сразу
        fetchTodayRooms();
        
        // Обновляем каждые 3 секунды
        if (window.dispatchersTodayRoomsInterval) {
            clearInterval(window.dispatchersTodayRoomsInterval);
        }
        window.dispatchersTodayRoomsInterval = setInterval(fetchTodayRooms, 3000);
    }

    // Основная функция инициализации депатчеров
    function initDispatchers() {
        console.log('Инициализация депатчеров...');
        
        // Загружаем номера из беседы (для всех версий)
        loadTodayRooms();
        
        // Инициализируем обработчики событий для обеих версий
        initDispatchersEventHandlers();
        
        // Загружаем выделенные номера при загрузке страницы
        loadDispatchersSelectionFromFirebase();
        
        // Настраиваем слушатель реального времени
        setupDispatchersRealtimeListener();
        
        // Обновляем счетчик при загрузке страницы
        updateDispatchersSelectedCount();
        
        console.log('Депатчеры инициализированы');
    }

    // Экспортируем функции в глобальную область для использования в onclick
    window.printDepartures = printDepartures;
    window.dispatchersPrintDepartures = printDepartures;
    window.dispatchersClearResults = clearResults;
    window.dispatchersInit = initDispatchers;
    window.loadDispatchersSelectionFromFirebase = loadDispatchersSelectionFromFirebase;
    window.renderDispatchersRooms = initializeRoomGrid;
    window.getAllRoomNumbers = getAllRoomNumbers;

    // Автоматическая инициализация при загрузке страницы
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM загружен, инициализируем депатчеры...');
        
        // Инициализируем сразу
        initDispatchers();
        
        // Дополнительная инициализация при переключении на вкладку депатчеров
        const dispatchersTab = document.querySelector('[data-tab="dispatchers"]');
        if (dispatchersTab) {
            dispatchersTab.addEventListener('click', function() {
                console.log('Переключение на вкладку депатчеров');
                setTimeout(initDispatchers, 100);
            });
        }

        // Обработчики для кнопок депатчеров
        const processBtn = document.getElementById('dispatchers-processBtn');
        const selectFileBtn = document.getElementById('dispatchers-selectFileBtn');
        const fileInput = document.getElementById('dispatchers-pdfFile');
        const fileNameSpan = document.getElementById('dispatchers-fileName');
        
        if (processBtn) {
            processBtn.addEventListener('click', processPDFWithExclusion);
        }
        
        // Обработчик кнопки выбора файла
        if (selectFileBtn && fileInput) {
            selectFileBtn.addEventListener('click', function() {
                fileInput.click();
            });
        }
        
        // Отображение имени выбранного файла и автоматический запуск обработки PDF
        if (fileInput && fileNameSpan) {
            fileInput.addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (file) {
                    fileNameSpan.textContent = file.name;

                    // Автоматически запускаем обработку PDF
                    try {
                        await processPDFWithExclusion();
                    } catch (err) {
                        console.error('Ошибка автоматической обработки PDF:', err);
                    }
                } else {
                    fileNameSpan.textContent = '';
                }
            });
        }
        
        // Drag and drop для файлов
        if (fileInput) {
            const selectFileBtn = document.getElementById('dispatchers-selectFileBtn');
            const container = selectFileBtn ? selectFileBtn.closest('.card') : null;
            
            if (container) {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    container.style.background = 'rgba(39,103,73,0.1)';
                });
                
                container.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    container.style.background = '';
                });
                
                container.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    container.style.background = '';
                    if (e.dataTransfer.files.length) {
                        fileInput.files = e.dataTransfer.files;
                        // Обновляем имя файла
                        if (fileNameSpan && fileInput.files[0]) {
                            fileNameSpan.textContent = fileInput.files[0].name;
                        }
                        // И сразу обрабатываем PDF
                        try {
                            await processPDFWithExclusion();
                        } catch (err) {
                            console.error('Ошибка обработки PDF при drag-and-drop:', err);
                        }
                    }
                });
            }
        }
    });

    // Принудительная инициализация при загрузке скрипта
    console.log('Скрипт депатчеров загружен');
    
    // Если DOM уже загружен, инициализируем сразу
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDispatchers);
    } else {
        setTimeout(initDispatchers, 100);
    }
})();

// Автоматическая инициализация депатчеров при показе вкладки
(function() {
    const originalShowTab = window.showTab;
    window.showTab = function(tab) {
        if (originalShowTab) originalShowTab(tab);
        
        if (tab === 'dispatchers') {
            console.log('Показана вкладка депатчеров, инициализируем...');
            // Небольшая задержка для гарантии что DOM обновлен
            setTimeout(() => {
                if (typeof window.dispatchersInit === 'function') {
                    window.dispatchersInit();
                }
            }, 50);
        }
    };
})();

// ==== ПУСТЫЕ: Инициализация и загрузка данных ====
(function() {
    const API_BASE = 'https://minibarbot.onrender.com';
    const EMPTIED_URL = API_BASE + '/emptied-rooms';
    
    let emptiedRoomsInterval = null;
    
    // Функция для форматирования времени из timestamp (как в Депатчерах)
    function timeStringFromUnix(tsSec) {
        if (!tsSec || typeof tsSec !== 'number') return null;
        // UTC+5 (Екатеринбург)
        const offsetMs = 5 * 60 * 60 * 1000;
        const d = new Date(tsSec * 1000 + offsetMs);
        const h = String(d.getUTCHours()).padStart(2, '0');
        const m = String(d.getUTCMinutes()).padStart(2, '0');
        return `${h}:${m}`;
    }
    
    // Функция для форматирования даты и времени из timestamp
    function dateTimeStringFromUnix(tsSec) {
        if (!tsSec || typeof tsSec !== 'number') return null;
        // UTC+5 (Екатеринбург)
        const offsetMs = 5 * 60 * 60 * 1000;
        const d = new Date(tsSec * 1000 + offsetMs);
        const day = String(d.getUTCDate()).padStart(2, '0');
        const month = String(d.getUTCMonth() + 1).padStart(2, '0');
        const h = String(d.getUTCHours()).padStart(2, '0');
        const m = String(d.getUTCMinutes()).padStart(2, '0');
        return `${day}.${month} ${h}:${m}`;
    }
    
    // Функция для парсинга времени для сортировки
    function parseTime(timeStr) {
        if (!timeStr) return 0;
        const parts = timeStr.split(':');
        if (parts.length !== 2) return 0;
        return parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
    }
    
    // Режим сортировки: 'time' или 'floor'
    let emptiedSortMode = localStorage.getItem('emptiedSortMode') || 'time';
    
    // Функция для группировки номеров по этажам
    function groupEmptiedRoomsByFloor(rooms) {
        const floors = {};
        rooms.forEach(roomData => {
            const roomStr = String(roomData.room || roomData);
            let floor;
            if (roomStr.length === 3) {
                floor = roomStr.charAt(0);
            } else {
                floor = roomStr.substring(0, 2);
            }
            if (!floors[floor]) {
                floors[floor] = [];
            }
            floors[floor].push(roomData);
        });
        return floors;
    }
    
    // Функция для отображения опустошённых номеров
    function renderEmptiedRooms(rooms) {
        const statusEl = document.getElementById('emptied-status');
        const roomsEl = document.getElementById('emptied-rooms-list');
        const totalCountEl = document.getElementById('emptied-total-count');
        
        if (!statusEl || !roomsEl || !totalCountEl) return;
        
        if (!rooms || rooms.length === 0) {
            statusEl.textContent = 'Нет пустых номеров';
            roomsEl.innerHTML = '';
            totalCountEl.textContent = '0';
            return;
        }
        
        statusEl.textContent = '';
        totalCountEl.textContent = String(rooms.length);
        
        // Сохраняем данные для перерисовки при смене режима сортировки
        window.emptiedRoomsData = rooms;
        
        // Подготавливаем данные с временем
        const roomsWithTime = rooms.map(roomData => {
            const room = String(roomData.room || roomData);
            const ts = roomData.ts || null;
            const time = dateTimeStringFromUnix(ts);
            return { room, ts, time };
        });
        
        if (emptiedSortMode === 'floor') {
            // Группировка по этажам
            roomsEl.classList.add('floor-mode');
            const floors = groupEmptiedRoomsByFloor(roomsWithTime);
            const sortedFloors = Object.keys(floors).sort((a, b) => {
                const ai = parseInt(a, 10);
                const bi = parseInt(b, 10);
                if (Number.isNaN(ai) && Number.isNaN(bi)) return a.localeCompare(b, 'ru');
                if (Number.isNaN(ai)) return 1;
                if (Number.isNaN(bi)) return -1;
                return ai - bi;
            });
            
            roomsEl.innerHTML = '';
            
            sortedFloors.forEach(floor => {
                const floorSection = document.createElement('div');
                floorSection.className = 'dispatchers-floor-section';
                floorSection.style.marginBottom = '12px';
                
                const floorTitle = document.createElement('div');
                floorTitle.className = 'dispatchers-floor-title';
                floorTitle.textContent = `${floor} этаж (${floors[floor].length})`;
                floorSection.appendChild(floorTitle);
                
                const roomList = document.createElement('div');
                roomList.className = 'dispatchers-room-list';
                
                const sortedRooms = floors[floor].sort((a, b) => {
                    const aRoom = parseInt(a.room || a);
                    const bRoom = parseInt(b.room || b);
                    return aRoom - bRoom;
                });
                
                sortedRooms.forEach(r => {
                    const card = document.createElement('div');
                    card.className = 'dispatchers-today-room-card';
                    card.dataset.room = r.room;
                    
                    card.innerHTML = `
                        <div class="dispatchers-today-room-number">${r.room}</div>
                        ${r.time ? `<div class="dispatchers-today-room-time">${r.time}</div>` : ''}
                    `;
                    
                    // Значок опустошения (∅)
                    const emptyMark = document.createElement('div');
                    emptyMark.className = 'dispatchers-today-room-empty';
                    emptyMark.textContent = '∅';
                    card.appendChild(emptyMark);
                    
                    roomList.appendChild(card);
                });
                
                floorSection.appendChild(roomList);
                roomsEl.appendChild(floorSection);
            });
        } else {
            // Сортировка по времени
            roomsEl.classList.remove('floor-mode');
            roomsEl.innerHTML = '';
            
            const sortedRoomsByTime = roomsWithTime.slice().sort((a, b) => {
                if (!a.ts && !b.ts) return parseInt(a.room) - parseInt(b.room);
                if (!a.ts) return 1;
                if (!b.ts) return -1;
                return a.ts - b.ts;
            });
            
            sortedRoomsByTime.forEach(r => {
                const card = document.createElement('div');
                card.className = 'dispatchers-today-room-card';
                card.dataset.room = r.room;
                
                card.innerHTML = `
                    <div class="dispatchers-today-room-number">${r.room}</div>
                    ${r.time ? `<div class="dispatchers-today-room-time">${r.time}</div>` : ''}
                `;
                
                // Значок опустошения (∅)
                const emptyMark = document.createElement('div');
                emptyMark.className = 'dispatchers-today-room-empty';
                emptyMark.textContent = '∅';
                card.appendChild(emptyMark);
                
                roomsEl.appendChild(card);
            });
        }
    }
    
    // Функция для переключения режима сортировки
    function toggleEmptiedSortMode() {
        emptiedSortMode = emptiedSortMode === 'time' ? 'floor' : 'time';
        localStorage.setItem('emptiedSortMode', emptiedSortMode);
        
        const sortLabel = document.getElementById('emptied-sort-label');
        if (sortLabel) {
            sortLabel.textContent = emptiedSortMode === 'time' ? 'По времени' : 'По этажам';
        }
        
        // Перерисовываем с сохранёнными данными
        if (window.emptiedRoomsData) {
            renderEmptiedRooms(window.emptiedRoomsData);
        }
    }
    
    // Функция для загрузки опустошённых номеров
    async function fetchEmptiedRooms() {
        const statusEl = document.getElementById('emptied-status');
        const roomsEl = document.getElementById('emptied-rooms-list');
        
        if (!statusEl || !roomsEl) return;
        
        try {
            const resp = await fetch(EMPTIED_URL);
            const data = await resp.json();
            
            if (!resp.ok) {
                statusEl.innerHTML = '<span style="color:var(--error);">Ошибка сервера: ' + (data.message || data.error || resp.status) + '</span>';
                roomsEl.innerHTML = '';
                return;
            }
            
            const rooms = data.rooms || [];
            renderEmptiedRooms(rooms);
            
        } catch (e) {
            statusEl.innerHTML = '<span style="color:var(--error);">Ошибка при запросе к бэкенду: ' + e.message + '</span>';
            roomsEl.innerHTML = '';
        }
    }
    
    // Функция инициализации
    function initEmptied() {
        console.log('Инициализация вкладки "Пустые"...');
        
        // Загружаем режим сортировки из localStorage
        emptiedSortMode = localStorage.getItem('emptiedSortMode') || 'time';
        
        // Устанавливаем начальную метку кнопки сортировки
        const sortLabel = document.getElementById('emptied-sort-label');
        if (sortLabel) {
            sortLabel.textContent = emptiedSortMode === 'time' ? 'По времени' : 'По этажам';
        }
        
        // Обработчик кнопки сортировки
        const sortToggle = document.getElementById('emptied-sort-toggle');
        if (sortToggle) {
            sortToggle.addEventListener('click', toggleEmptiedSortMode);
        }
        
        // Загружаем сразу
        fetchEmptiedRooms();
        
        // Обновляем каждые 5 секунд
        if (emptiedRoomsInterval) {
            clearInterval(emptiedRoomsInterval);
        }
        emptiedRoomsInterval = setInterval(fetchEmptiedRooms, 5000);
    }
    
    // Экспортируем функцию инициализации
    window.emptiedInit = initEmptied;
    
    // Автоматическая инициализация при показе вкладки
    const originalShowTab = window.showTab;
    window.showTab = function(tab) {
        if (originalShowTab) originalShowTab(tab);
        
        if (tab === 'emptied') {
            console.log('Показана вкладка "Пустые", инициализируем...');
            setTimeout(() => {
                if (typeof window.emptiedInit === 'function') {
                    window.emptiedInit();
                }
            }, 50);
        } else {
            // Останавливаем обновление при переключении на другую вкладку
            if (emptiedRoomsInterval) {
                clearInterval(emptiedRoomsInterval);
                emptiedRoomsInterval = null;
            }
        }
    };
    
    // Инициализация при загрузке страницы, если вкладка уже активна
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            const activeTab = document.querySelector('.nav-item.active')?.dataset?.tab || 
                             localStorage.getItem('minibar-active-tab') || 
                             localStorage.getItem('active-tab') || 
                             'accises';
            if (activeTab === 'emptied') {
                setTimeout(initEmptied, 100);
            }
        });
    } else {
        const activeTab = document.querySelector('.nav-item.active')?.dataset?.tab || 
                         localStorage.getItem('minibar-active-tab') || 
                         localStorage.getItem('active-tab') || 
                         'accises';
        if (activeTab === 'emptied') {
            setTimeout(initEmptied, 100);
        }
    }
})();
</script>
</div>
<div class="bottom-line"></div>
</body>
</html>


